/*
 * automatically generated by rust-bindgen
 * From upstream linux include/uapi/linux/elf.h at commit:
 * 806276b7f07a39a1cc3f38bb1ef5c573d4594a38
 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const EM_NONE: ::std::os::raw::c_uint = 0;
pub const EM_M32: ::std::os::raw::c_uint = 1;
pub const EM_SPARC: ::std::os::raw::c_uint = 2;
pub const EM_386: ::std::os::raw::c_uint = 3;
pub const EM_68K: ::std::os::raw::c_uint = 4;
pub const EM_88K: ::std::os::raw::c_uint = 5;
pub const EM_486: ::std::os::raw::c_uint = 6;
pub const EM_860: ::std::os::raw::c_uint = 7;
pub const EM_MIPS: ::std::os::raw::c_uint = 8;
pub const EM_MIPS_RS3_LE: ::std::os::raw::c_uint = 10;
pub const EM_MIPS_RS4_BE: ::std::os::raw::c_uint = 10;
pub const EM_PARISC: ::std::os::raw::c_uint = 15;
pub const EM_SPARC32PLUS: ::std::os::raw::c_uint = 18;
pub const EM_PPC: ::std::os::raw::c_uint = 20;
pub const EM_PPC64: ::std::os::raw::c_uint = 21;
pub const EM_SPU: ::std::os::raw::c_uint = 23;
pub const EM_ARM: ::std::os::raw::c_uint = 40;
pub const EM_SH: ::std::os::raw::c_uint = 42;
pub const EM_SPARCV9: ::std::os::raw::c_uint = 43;
pub const EM_H8_300: ::std::os::raw::c_uint = 46;
pub const EM_IA_64: ::std::os::raw::c_uint = 50;
pub const EM_X86_64: ::std::os::raw::c_uint = 62;
pub const EM_S390: ::std::os::raw::c_uint = 22;
pub const EM_CRIS: ::std::os::raw::c_uint = 76;
pub const EM_V850: ::std::os::raw::c_uint = 87;
pub const EM_M32R: ::std::os::raw::c_uint = 88;
pub const EM_MN10300: ::std::os::raw::c_uint = 89;
pub const EM_OPENRISC: ::std::os::raw::c_uint = 92;
pub const EM_BLACKFIN: ::std::os::raw::c_uint = 106;
pub const EM_ALTERA_NIOS2: ::std::os::raw::c_uint = 113;
pub const EM_TI_C6000: ::std::os::raw::c_uint = 140;
pub const EM_AARCH64: ::std::os::raw::c_uint = 183;
pub const EM_TILEPRO: ::std::os::raw::c_uint = 188;
pub const EM_MICROBLAZE: ::std::os::raw::c_uint = 189;
pub const EM_TILEGX: ::std::os::raw::c_uint = 191;
pub const EM_FRV: ::std::os::raw::c_uint = 21569;
pub const EM_AVR32: ::std::os::raw::c_uint = 6317;
pub const EM_ALPHA: ::std::os::raw::c_uint = 36902;
pub const EM_CYGNUS_V850: ::std::os::raw::c_uint = 36992;
pub const EM_CYGNUS_M32R: ::std::os::raw::c_uint = 36929;
pub const EM_S390_OLD: ::std::os::raw::c_uint = 41872;
pub const EM_CYGNUS_MN10300: ::std::os::raw::c_uint = 48879;
pub const PT_NULL: ::std::os::raw::c_uint = 0;
pub const PT_LOAD: ::std::os::raw::c_uint = 1;
pub const PT_DYNAMIC: ::std::os::raw::c_uint = 2;
pub const PT_INTERP: ::std::os::raw::c_uint = 3;
pub const PT_NOTE: ::std::os::raw::c_uint = 4;
pub const PT_SHLIB: ::std::os::raw::c_uint = 5;
pub const PT_PHDR: ::std::os::raw::c_uint = 6;
pub const PT_TLS: ::std::os::raw::c_uint = 7;
pub const PT_LOOS: ::std::os::raw::c_uint = 1610612736;
pub const PT_HIOS: ::std::os::raw::c_uint = 1879048191;
pub const PT_LOPROC: ::std::os::raw::c_uint = 1879048192;
pub const PT_HIPROC: ::std::os::raw::c_uint = 2147483647;
pub const PT_GNU_EH_FRAME: ::std::os::raw::c_uint = 1685382480;
pub const PT_GNU_STACK: ::std::os::raw::c_uint = 1685382481;
pub const PN_XNUM: ::std::os::raw::c_uint = 65535;
pub const ET_NONE: ::std::os::raw::c_uint = 0;
pub const ET_REL: ::std::os::raw::c_uint = 1;
pub const ET_EXEC: ::std::os::raw::c_uint = 2;
pub const ET_DYN: ::std::os::raw::c_uint = 3;
pub const ET_CORE: ::std::os::raw::c_uint = 4;
pub const ET_LOPROC: ::std::os::raw::c_uint = 65280;
pub const ET_HIPROC: ::std::os::raw::c_uint = 65535;
pub const DT_NULL: ::std::os::raw::c_uint = 0;
pub const DT_NEEDED: ::std::os::raw::c_uint = 1;
pub const DT_PLTRELSZ: ::std::os::raw::c_uint = 2;
pub const DT_PLTGOT: ::std::os::raw::c_uint = 3;
pub const DT_HASH: ::std::os::raw::c_uint = 4;
pub const DT_STRTAB: ::std::os::raw::c_uint = 5;
pub const DT_SYMTAB: ::std::os::raw::c_uint = 6;
pub const DT_RELA: ::std::os::raw::c_uint = 7;
pub const DT_RELASZ: ::std::os::raw::c_uint = 8;
pub const DT_RELAENT: ::std::os::raw::c_uint = 9;
pub const DT_STRSZ: ::std::os::raw::c_uint = 10;
pub const DT_SYMENT: ::std::os::raw::c_uint = 11;
pub const DT_INIT: ::std::os::raw::c_uint = 12;
pub const DT_FINI: ::std::os::raw::c_uint = 13;
pub const DT_SONAME: ::std::os::raw::c_uint = 14;
pub const DT_RPATH: ::std::os::raw::c_uint = 15;
pub const DT_SYMBOLIC: ::std::os::raw::c_uint = 16;
pub const DT_REL: ::std::os::raw::c_uint = 17;
pub const DT_RELSZ: ::std::os::raw::c_uint = 18;
pub const DT_RELENT: ::std::os::raw::c_uint = 19;
pub const DT_PLTREL: ::std::os::raw::c_uint = 20;
pub const DT_DEBUG: ::std::os::raw::c_uint = 21;
pub const DT_TEXTREL: ::std::os::raw::c_uint = 22;
pub const DT_JMPREL: ::std::os::raw::c_uint = 23;
pub const DT_ENCODING: ::std::os::raw::c_uint = 32;
pub const OLD_DT_LOOS: ::std::os::raw::c_uint = 1610612736;
pub const DT_LOOS: ::std::os::raw::c_uint = 1610612749;
pub const DT_HIOS: ::std::os::raw::c_uint = 1879044096;
pub const DT_VALRNGLO: ::std::os::raw::c_uint = 1879047424;
pub const DT_VALRNGHI: ::std::os::raw::c_uint = 1879047679;
pub const DT_ADDRRNGLO: ::std::os::raw::c_uint = 1879047680;
pub const DT_ADDRRNGHI: ::std::os::raw::c_uint = 1879047935;
pub const DT_VERSYM: ::std::os::raw::c_uint = 1879048176;
pub const DT_RELACOUNT: ::std::os::raw::c_uint = 1879048185;
pub const DT_RELCOUNT: ::std::os::raw::c_uint = 1879048186;
pub const DT_FLAGS_1: ::std::os::raw::c_uint = 1879048187;
pub const DT_VERDEF: ::std::os::raw::c_uint = 1879048188;
pub const DT_VERDEFNUM: ::std::os::raw::c_uint = 1879048189;
pub const DT_VERNEED: ::std::os::raw::c_uint = 1879048190;
pub const DT_VERNEEDNUM: ::std::os::raw::c_uint = 1879048191;
pub const OLD_DT_HIOS: ::std::os::raw::c_uint = 1879048191;
pub const DT_LOPROC: ::std::os::raw::c_uint = 1879048192;
pub const DT_HIPROC: ::std::os::raw::c_uint = 2147483647;
pub const STB_LOCAL: ::std::os::raw::c_uint = 0;
pub const STB_GLOBAL: ::std::os::raw::c_uint = 1;
pub const STB_WEAK: ::std::os::raw::c_uint = 2;
pub const STT_NOTYPE: ::std::os::raw::c_uint = 0;
pub const STT_OBJECT: ::std::os::raw::c_uint = 1;
pub const STT_FUNC: ::std::os::raw::c_uint = 2;
pub const STT_SECTION: ::std::os::raw::c_uint = 3;
pub const STT_FILE: ::std::os::raw::c_uint = 4;
pub const STT_COMMON: ::std::os::raw::c_uint = 5;
pub const STT_TLS: ::std::os::raw::c_uint = 6;
pub const EI_NIDENT: ::std::os::raw::c_uint = 16;
pub const PF_R: ::std::os::raw::c_uint = 4;
pub const PF_W: ::std::os::raw::c_uint = 2;
pub const PF_X: ::std::os::raw::c_uint = 1;
pub const SHT_NULL: ::std::os::raw::c_uint = 0;
pub const SHT_PROGBITS: ::std::os::raw::c_uint = 1;
pub const SHT_SYMTAB: ::std::os::raw::c_uint = 2;
pub const SHT_STRTAB: ::std::os::raw::c_uint = 3;
pub const SHT_RELA: ::std::os::raw::c_uint = 4;
pub const SHT_HASH: ::std::os::raw::c_uint = 5;
pub const SHT_DYNAMIC: ::std::os::raw::c_uint = 6;
pub const SHT_NOTE: ::std::os::raw::c_uint = 7;
pub const SHT_NOBITS: ::std::os::raw::c_uint = 8;
pub const SHT_REL: ::std::os::raw::c_uint = 9;
pub const SHT_SHLIB: ::std::os::raw::c_uint = 10;
pub const SHT_DYNSYM: ::std::os::raw::c_uint = 11;
pub const SHT_NUM: ::std::os::raw::c_uint = 12;
pub const SHT_LOPROC: ::std::os::raw::c_uint = 1879048192;
pub const SHT_HIPROC: ::std::os::raw::c_uint = 2147483647;
pub const SHT_LOUSER: ::std::os::raw::c_uint = 2147483648;
pub const SHT_HIUSER: ::std::os::raw::c_uint = 4294967295;
pub const SHF_WRITE: ::std::os::raw::c_uint = 1;
pub const SHF_ALLOC: ::std::os::raw::c_uint = 2;
pub const SHF_EXECINSTR: ::std::os::raw::c_uint = 4;
pub const SHF_MASKPROC: ::std::os::raw::c_uint = 4026531840;
pub const SHN_UNDEF: ::std::os::raw::c_uint = 0;
pub const SHN_LORESERVE: ::std::os::raw::c_uint = 65280;
pub const SHN_LOPROC: ::std::os::raw::c_uint = 65280;
pub const SHN_HIPROC: ::std::os::raw::c_uint = 65311;
pub const SHN_ABS: ::std::os::raw::c_uint = 65521;
pub const SHN_COMMON: ::std::os::raw::c_uint = 65522;
pub const SHN_HIRESERVE: ::std::os::raw::c_uint = 65535;
pub const EI_MAG0: ::std::os::raw::c_uint = 0;
pub const EI_MAG1: ::std::os::raw::c_uint = 1;
pub const EI_MAG2: ::std::os::raw::c_uint = 2;
pub const EI_MAG3: ::std::os::raw::c_uint = 3;
pub const EI_CLASS: ::std::os::raw::c_uint = 4;
pub const EI_DATA: ::std::os::raw::c_uint = 5;
pub const EI_VERSION: ::std::os::raw::c_uint = 6;
pub const EI_OSABI: ::std::os::raw::c_uint = 7;
pub const EI_PAD: ::std::os::raw::c_uint = 8;
pub const ELFMAG0: ::std::os::raw::c_uint = 127;
pub const ELFMAG1: u8 = b'E';
pub const ELFMAG2: u8 = b'L';
pub const ELFMAG3: u8 = b'F';
pub const ELFMAG: &'static [u8; 5usize] = b"\x7fELF\x00";
pub const SELFMAG: ::std::os::raw::c_uint = 4;
pub const ELFCLASSNONE: ::std::os::raw::c_uint = 0;
pub const ELFCLASS32: ::std::os::raw::c_uint = 1;
pub const ELFCLASS64: ::std::os::raw::c_uint = 2;
pub const ELFCLASSNUM: ::std::os::raw::c_uint = 3;
pub const ELFDATANONE: ::std::os::raw::c_uint = 0;
pub const ELFDATA2LSB: ::std::os::raw::c_uint = 1;
pub const ELFDATA2MSB: ::std::os::raw::c_uint = 2;
pub const EV_NONE: ::std::os::raw::c_uint = 0;
pub const EV_CURRENT: ::std::os::raw::c_uint = 1;
pub const EV_NUM: ::std::os::raw::c_uint = 2;
pub const ELFOSABI_NONE: ::std::os::raw::c_uint = 0;
pub const ELFOSABI_LINUX: ::std::os::raw::c_uint = 3;
pub const ELF_OSABI: ::std::os::raw::c_uint = 0;
pub const NT_PRSTATUS: ::std::os::raw::c_uint = 1;
pub const NT_PRFPREG: ::std::os::raw::c_uint = 2;
pub const NT_PRPSINFO: ::std::os::raw::c_uint = 3;
pub const NT_TASKSTRUCT: ::std::os::raw::c_uint = 4;
pub const NT_AUXV: ::std::os::raw::c_uint = 6;
pub const NT_SIGINFO: ::std::os::raw::c_uint = 1397311305;
pub const NT_FILE: ::std::os::raw::c_uint = 1179208773;
pub const NT_PRXFPREG: ::std::os::raw::c_uint = 1189489535;
pub const NT_PPC_VMX: ::std::os::raw::c_uint = 256;
pub const NT_PPC_SPE: ::std::os::raw::c_uint = 257;
pub const NT_PPC_VSX: ::std::os::raw::c_uint = 258;
pub const NT_386_TLS: ::std::os::raw::c_uint = 512;
pub const NT_386_IOPERM: ::std::os::raw::c_uint = 513;
pub const NT_X86_XSTATE: ::std::os::raw::c_uint = 514;
pub const NT_S390_HIGH_GPRS: ::std::os::raw::c_uint = 768;
pub const NT_S390_TIMER: ::std::os::raw::c_uint = 769;
pub const NT_S390_TODCMP: ::std::os::raw::c_uint = 770;
pub const NT_S390_TODPREG: ::std::os::raw::c_uint = 771;
pub const NT_S390_CTRS: ::std::os::raw::c_uint = 772;
pub const NT_S390_PREFIX: ::std::os::raw::c_uint = 773;
pub const NT_S390_LAST_BREAK: ::std::os::raw::c_uint = 774;
pub const NT_S390_SYSTEM_CALL: ::std::os::raw::c_uint = 775;
pub const NT_S390_TDB: ::std::os::raw::c_uint = 776;
pub const NT_S390_VXRS_LOW: ::std::os::raw::c_uint = 777;
pub const NT_S390_VXRS_HIGH: ::std::os::raw::c_uint = 778;
pub const NT_ARM_VFP: ::std::os::raw::c_uint = 1024;
pub const NT_ARM_TLS: ::std::os::raw::c_uint = 1025;
pub const NT_ARM_HW_BREAK: ::std::os::raw::c_uint = 1026;
pub const NT_ARM_HW_WATCH: ::std::os::raw::c_uint = 1027;
pub const NT_ARM_SYSTEM_CALL: ::std::os::raw::c_uint = 1028;
pub const NT_METAG_CBUF: ::std::os::raw::c_uint = 1280;
pub const NT_METAG_RPIPE: ::std::os::raw::c_uint = 1281;
pub const NT_METAG_TLS: ::std::os::raw::c_uint = 1282;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>(),
               128usize,
               concat!("Size of: ", stringify!(__kernel_fd_set)));
    assert_eq!(::std::mem::align_of::<__kernel_fd_set>(),
               8usize,
               concat!("Alignment of ", stringify!(__kernel_fd_set)));
    assert_eq!(unsafe { &(*(0 as *const __kernel_fd_set)).fds_bits as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__kernel_fd_set),
                       "::",
                       stringify!(fds_bits)));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>(),
               8usize,
               concat!("Size of: ", stringify!(__kernel_fsid_t)));
    assert_eq!(::std::mem::align_of::<__kernel_fsid_t>(),
               4usize,
               concat!("Alignment of ", stringify!(__kernel_fsid_t)));
    assert_eq!(unsafe { &(*(0 as *const __kernel_fsid_t)).val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__kernel_fsid_t),
                       "::",
                       stringify!(val)));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type Elf32_Addr = __u32;
pub type Elf32_Half = __u16;
pub type Elf32_Off = __u32;
pub type Elf32_Sword = __s32;
pub type Elf32_Word = __u32;
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_SHalf = __s16;
pub type Elf64_Off = __u64;
pub type Elf64_Sword = __s32;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
pub type Elf64_Sxword = __s64;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct dynamic {
    pub d_tag: Elf32_Sword,
    pub d_un: dynamic__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct dynamic__bindgen_ty_1 {
    pub d_val: __BindgenUnionField<Elf32_Sword>,
    pub d_ptr: __BindgenUnionField<Elf32_Addr>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_dynamic__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dynamic__bindgen_ty_1>(),
               4usize,
               concat!("Size of: ", stringify!(dynamic__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<dynamic__bindgen_ty_1>(),
               4usize,
               concat!("Alignment of ", stringify!(dynamic__bindgen_ty_1)));
    assert_eq!(unsafe { &(*(0 as *const dynamic__bindgen_ty_1)).d_val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(dynamic__bindgen_ty_1),
                       "::",
                       stringify!(d_val)));
    assert_eq!(unsafe { &(*(0 as *const dynamic__bindgen_ty_1)).d_ptr as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(dynamic__bindgen_ty_1),
                       "::",
                       stringify!(d_ptr)));
}
impl Clone for dynamic__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_dynamic() {
    assert_eq!(::std::mem::size_of::<dynamic>(),
               8usize,
               concat!("Size of: ", stringify!(dynamic)));
    assert_eq!(::std::mem::align_of::<dynamic>(),
               4usize,
               concat!("Alignment of ", stringify!(dynamic)));
    assert_eq!(unsafe { &(*(0 as *const dynamic)).d_tag as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(dynamic),
                       "::",
                       stringify!(d_tag)));
    assert_eq!(unsafe { &(*(0 as *const dynamic)).d_un as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(dynamic),
                       "::",
                       stringify!(d_un)));
}
impl Clone for dynamic {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Dyn = dynamic;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct Elf64_Dyn {
    pub d_tag: Elf64_Sxword,
    pub d_un: Elf64_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct Elf64_Dyn__bindgen_ty_1 {
    pub d_val: __BindgenUnionField<Elf64_Xword>,
    pub d_ptr: __BindgenUnionField<Elf64_Addr>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_Elf64_Dyn__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<Elf64_Dyn__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ", stringify!(Elf64_Dyn__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<Elf64_Dyn__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ", stringify!(Elf64_Dyn__bindgen_ty_1)));
    assert_eq!(unsafe { &(*(0 as *const Elf64_Dyn__bindgen_ty_1)).d_val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(Elf64_Dyn__bindgen_ty_1),
                       "::",
                       stringify!(d_val)));
    assert_eq!(unsafe { &(*(0 as *const Elf64_Dyn__bindgen_ty_1)).d_ptr as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(Elf64_Dyn__bindgen_ty_1),
                       "::",
                       stringify!(d_ptr)));
}
impl Clone for Elf64_Dyn__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_Elf64_Dyn() {
    assert_eq!(::std::mem::size_of::<Elf64_Dyn>(),
               16usize,
               concat!("Size of: ", stringify!(Elf64_Dyn)));
    assert_eq!(::std::mem::align_of::<Elf64_Dyn>(),
               8usize,
               concat!("Alignment of ", stringify!(Elf64_Dyn)));
    assert_eq!(unsafe { &(*(0 as *const Elf64_Dyn)).d_tag as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(Elf64_Dyn),
                       "::",
                       stringify!(d_tag)));
    assert_eq!(unsafe { &(*(0 as *const Elf64_Dyn)).d_un as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(Elf64_Dyn),
                       "::",
                       stringify!(d_un)));
}
impl Clone for Elf64_Dyn {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_rel {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
}
#[test]
fn bindgen_test_layout_elf32_rel() {
    assert_eq!(::std::mem::size_of::<elf32_rel>(),
               8usize,
               concat!("Size of: ", stringify!(elf32_rel)));
    assert_eq!(::std::mem::align_of::<elf32_rel>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_rel)));
    assert_eq!(unsafe { &(*(0 as *const elf32_rel)).r_offset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_rel),
                       "::",
                       stringify!(r_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf32_rel)).r_info as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_rel),
                       "::",
                       stringify!(r_info)));
}
impl Clone for elf32_rel {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Rel = elf32_rel;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_rel {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_rel() {
    assert_eq!(::std::mem::size_of::<elf64_rel>(),
               16usize,
               concat!("Size of: ", stringify!(elf64_rel)));
    assert_eq!(::std::mem::align_of::<elf64_rel>(),
               8usize,
               concat!("Alignment of ", stringify!(elf64_rel)));
    assert_eq!(unsafe { &(*(0 as *const elf64_rel)).r_offset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_rel),
                       "::",
                       stringify!(r_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf64_rel)).r_info as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_rel),
                       "::",
                       stringify!(r_info)));
}
impl Clone for elf64_rel {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Rel = elf64_rel;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_rela {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
    pub r_addend: Elf32_Sword,
}
#[test]
fn bindgen_test_layout_elf32_rela() {
    assert_eq!(::std::mem::size_of::<elf32_rela>(),
               12usize,
               concat!("Size of: ", stringify!(elf32_rela)));
    assert_eq!(::std::mem::align_of::<elf32_rela>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_rela)));
    assert_eq!(unsafe { &(*(0 as *const elf32_rela)).r_offset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_rela),
                       "::",
                       stringify!(r_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf32_rela)).r_info as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_rela),
                       "::",
                       stringify!(r_info)));
    assert_eq!(unsafe { &(*(0 as *const elf32_rela)).r_addend as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_rela),
                       "::",
                       stringify!(r_addend)));
}
impl Clone for elf32_rela {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Rela = elf32_rela;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_rela {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
    pub r_addend: Elf64_Sxword,
}
#[test]
fn bindgen_test_layout_elf64_rela() {
    assert_eq!(::std::mem::size_of::<elf64_rela>(),
               24usize,
               concat!("Size of: ", stringify!(elf64_rela)));
    assert_eq!(::std::mem::align_of::<elf64_rela>(),
               8usize,
               concat!("Alignment of ", stringify!(elf64_rela)));
    assert_eq!(unsafe { &(*(0 as *const elf64_rela)).r_offset as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_rela),
                       "::",
                       stringify!(r_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf64_rela)).r_info as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_rela),
                       "::",
                       stringify!(r_info)));
    assert_eq!(unsafe { &(*(0 as *const elf64_rela)).r_addend as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_rela),
                       "::",
                       stringify!(r_addend)));
}
impl Clone for elf64_rela {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Rela = elf64_rela;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_sym {
    pub st_name: Elf32_Word,
    pub st_value: Elf32_Addr,
    pub st_size: Elf32_Word,
    pub st_info: ::std::os::raw::c_uchar,
    pub st_other: ::std::os::raw::c_uchar,
    pub st_shndx: Elf32_Half,
}
#[test]
fn bindgen_test_layout_elf32_sym() {
    assert_eq!(::std::mem::size_of::<elf32_sym>(),
               16usize,
               concat!("Size of: ", stringify!(elf32_sym)));
    assert_eq!(::std::mem::align_of::<elf32_sym>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_sym)));
    assert_eq!(unsafe { &(*(0 as *const elf32_sym)).st_name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_sym),
                       "::",
                       stringify!(st_name)));
    assert_eq!(unsafe { &(*(0 as *const elf32_sym)).st_value as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_sym),
                       "::",
                       stringify!(st_value)));
    assert_eq!(unsafe { &(*(0 as *const elf32_sym)).st_size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_sym),
                       "::",
                       stringify!(st_size)));
    assert_eq!(unsafe { &(*(0 as *const elf32_sym)).st_info as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_sym),
                       "::",
                       stringify!(st_info)));
    assert_eq!(unsafe { &(*(0 as *const elf32_sym)).st_other as *const _ as usize },
               13usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_sym),
                       "::",
                       stringify!(st_other)));
    assert_eq!(unsafe { &(*(0 as *const elf32_sym)).st_shndx as *const _ as usize },
               14usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_sym),
                       "::",
                       stringify!(st_shndx)));
}
impl Clone for elf32_sym {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Sym = elf32_sym;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: ::std::os::raw::c_uchar,
    pub st_other: ::std::os::raw::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_sym() {
    assert_eq!(::std::mem::size_of::<elf64_sym>(),
               24usize,
               concat!("Size of: ", stringify!(elf64_sym)));
    assert_eq!(::std::mem::align_of::<elf64_sym>(),
               8usize,
               concat!("Alignment of ", stringify!(elf64_sym)));
    assert_eq!(unsafe { &(*(0 as *const elf64_sym)).st_name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_sym),
                       "::",
                       stringify!(st_name)));
    assert_eq!(unsafe { &(*(0 as *const elf64_sym)).st_info as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_sym),
                       "::",
                       stringify!(st_info)));
    assert_eq!(unsafe { &(*(0 as *const elf64_sym)).st_other as *const _ as usize },
               5usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_sym),
                       "::",
                       stringify!(st_other)));
    assert_eq!(unsafe { &(*(0 as *const elf64_sym)).st_shndx as *const _ as usize },
               6usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_sym),
                       "::",
                       stringify!(st_shndx)));
    assert_eq!(unsafe { &(*(0 as *const elf64_sym)).st_value as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_sym),
                       "::",
                       stringify!(st_value)));
    assert_eq!(unsafe { &(*(0 as *const elf64_sym)).st_size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_sym),
                       "::",
                       stringify!(st_size)));
}
impl Clone for elf64_sym {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_hdr {
    pub e_ident: [::std::os::raw::c_uchar; 16usize],
    pub e_type: Elf32_Half,
    pub e_machine: Elf32_Half,
    pub e_version: Elf32_Word,
    pub e_entry: Elf32_Addr,
    pub e_phoff: Elf32_Off,
    pub e_shoff: Elf32_Off,
    pub e_flags: Elf32_Word,
    pub e_ehsize: Elf32_Half,
    pub e_phentsize: Elf32_Half,
    pub e_phnum: Elf32_Half,
    pub e_shentsize: Elf32_Half,
    pub e_shnum: Elf32_Half,
    pub e_shstrndx: Elf32_Half,
}
#[test]
fn bindgen_test_layout_elf32_hdr() {
    assert_eq!(::std::mem::size_of::<elf32_hdr>(),
               52usize,
               concat!("Size of: ", stringify!(elf32_hdr)));
    assert_eq!(::std::mem::align_of::<elf32_hdr>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_hdr)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_ident as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_ident)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_type as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_type)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_machine as *const _ as usize },
               18usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_machine)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_version as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_version)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_entry as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_entry)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_phoff as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_phoff)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_shoff as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_shoff)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_flags as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_flags)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_ehsize as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_ehsize)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_phentsize as *const _ as usize },
               42usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_phentsize)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_phnum as *const _ as usize },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_phnum)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_shentsize as *const _ as usize },
               46usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_shentsize)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_shnum as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_shnum)));
    assert_eq!(unsafe { &(*(0 as *const elf32_hdr)).e_shstrndx as *const _ as usize },
               50usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_hdr),
                       "::",
                       stringify!(e_shstrndx)));
}
impl Clone for elf32_hdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Ehdr = elf32_hdr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_hdr {
    pub e_ident: [::std::os::raw::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
#[test]
fn bindgen_test_layout_elf64_hdr() {
    assert_eq!(::std::mem::size_of::<elf64_hdr>(),
               64usize,
               concat!("Size of: ", stringify!(elf64_hdr)));
    assert_eq!(::std::mem::align_of::<elf64_hdr>(),
               8usize,
               concat!("Alignment of ", stringify!(elf64_hdr)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_ident as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_ident)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_type as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_type)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_machine as *const _ as usize },
               18usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_machine)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_version as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_version)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_entry as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_entry)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_phoff as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_phoff)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_shoff as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_shoff)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_flags as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_flags)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_ehsize as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_ehsize)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_phentsize as *const _ as usize },
               54usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_phentsize)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_phnum as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_phnum)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_shentsize as *const _ as usize },
               58usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_shentsize)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_shnum as *const _ as usize },
               60usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_shnum)));
    assert_eq!(unsafe { &(*(0 as *const elf64_hdr)).e_shstrndx as *const _ as usize },
               62usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_hdr),
                       "::",
                       stringify!(e_shstrndx)));
}
impl Clone for elf64_hdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_phdr {
    pub p_type: Elf32_Word,
    pub p_offset: Elf32_Off,
    pub p_vaddr: Elf32_Addr,
    pub p_paddr: Elf32_Addr,
    pub p_filesz: Elf32_Word,
    pub p_memsz: Elf32_Word,
    pub p_flags: Elf32_Word,
    pub p_align: Elf32_Word,
}
#[test]
fn bindgen_test_layout_elf32_phdr() {
    assert_eq!(::std::mem::size_of::<elf32_phdr>(),
               32usize,
               concat!("Size of: ", stringify!(elf32_phdr)));
    assert_eq!(::std::mem::align_of::<elf32_phdr>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_phdr)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_type as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_type)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_offset as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_vaddr as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_vaddr)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_paddr as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_paddr)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_filesz as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_filesz)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_memsz as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_memsz)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_flags as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_flags)));
    assert_eq!(unsafe { &(*(0 as *const elf32_phdr)).p_align as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_phdr),
                       "::",
                       stringify!(p_align)));
}
impl Clone for elf32_phdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Phdr = elf32_phdr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_phdr {
    pub p_type: Elf64_Word,
    pub p_flags: Elf64_Word,
    pub p_offset: Elf64_Off,
    pub p_vaddr: Elf64_Addr,
    pub p_paddr: Elf64_Addr,
    pub p_filesz: Elf64_Xword,
    pub p_memsz: Elf64_Xword,
    pub p_align: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_phdr() {
    assert_eq!(::std::mem::size_of::<elf64_phdr>(),
               56usize,
               concat!("Size of: ", stringify!(elf64_phdr)));
    assert_eq!(::std::mem::align_of::<elf64_phdr>(),
               8usize,
               concat!("Alignment of ", stringify!(elf64_phdr)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_type as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_type)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_flags as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_flags)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_offset as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_vaddr as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_vaddr)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_paddr as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_paddr)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_filesz as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_filesz)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_memsz as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_memsz)));
    assert_eq!(unsafe { &(*(0 as *const elf64_phdr)).p_align as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_phdr),
                       "::",
                       stringify!(p_align)));
}
impl Clone for elf64_phdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Phdr = elf64_phdr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_shdr {
    pub sh_name: Elf32_Word,
    pub sh_type: Elf32_Word,
    pub sh_flags: Elf32_Word,
    pub sh_addr: Elf32_Addr,
    pub sh_offset: Elf32_Off,
    pub sh_size: Elf32_Word,
    pub sh_link: Elf32_Word,
    pub sh_info: Elf32_Word,
    pub sh_addralign: Elf32_Word,
    pub sh_entsize: Elf32_Word,
}
#[test]
fn bindgen_test_layout_elf32_shdr() {
    assert_eq!(::std::mem::size_of::<elf32_shdr>(),
               40usize,
               concat!("Size of: ", stringify!(elf32_shdr)));
    assert_eq!(::std::mem::align_of::<elf32_shdr>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_shdr)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_name)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_type as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_type)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_flags as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_flags)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_addr as *const _ as usize },
               12usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_addr)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_offset as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_size as *const _ as usize },
               20usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_size)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_link as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_link)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_info as *const _ as usize },
               28usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_info)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_addralign as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_addralign)));
    assert_eq!(unsafe { &(*(0 as *const elf32_shdr)).sh_entsize as *const _ as usize },
               36usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_shdr),
                       "::",
                       stringify!(sh_entsize)));
}
impl Clone for elf32_shdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Shdr = elf32_shdr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
#[test]
fn bindgen_test_layout_elf64_shdr() {
    assert_eq!(::std::mem::size_of::<elf64_shdr>(),
               64usize,
               concat!("Size of: ", stringify!(elf64_shdr)));
    assert_eq!(::std::mem::align_of::<elf64_shdr>(),
               8usize,
               concat!("Alignment of ", stringify!(elf64_shdr)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_name)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_type as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_type)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_flags as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_flags)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_addr as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_addr)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_offset as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_offset)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_size as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_size)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_link as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_link)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_info as *const _ as usize },
               44usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_info)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_addralign as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_addralign)));
    assert_eq!(unsafe { &(*(0 as *const elf64_shdr)).sh_entsize as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_shdr),
                       "::",
                       stringify!(sh_entsize)));
}
impl Clone for elf64_shdr {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf32_note {
    pub n_namesz: Elf32_Word,
    pub n_descsz: Elf32_Word,
    pub n_type: Elf32_Word,
}
#[test]
fn bindgen_test_layout_elf32_note() {
    assert_eq!(::std::mem::size_of::<elf32_note>(),
               12usize,
               concat!("Size of: ", stringify!(elf32_note)));
    assert_eq!(::std::mem::align_of::<elf32_note>(),
               4usize,
               concat!("Alignment of ", stringify!(elf32_note)));
    assert_eq!(unsafe { &(*(0 as *const elf32_note)).n_namesz as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_note),
                       "::",
                       stringify!(n_namesz)));
    assert_eq!(unsafe { &(*(0 as *const elf32_note)).n_descsz as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_note),
                       "::",
                       stringify!(n_descsz)));
    assert_eq!(unsafe { &(*(0 as *const elf32_note)).n_type as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf32_note),
                       "::",
                       stringify!(n_type)));
}
impl Clone for elf32_note {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf32_Nhdr = elf32_note;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct elf64_note {
    pub n_namesz: Elf64_Word,
    pub n_descsz: Elf64_Word,
    pub n_type: Elf64_Word,
}
#[test]
fn bindgen_test_layout_elf64_note() {
    assert_eq!(::std::mem::size_of::<elf64_note>(),
               12usize,
               concat!("Size of: ", stringify!(elf64_note)));
    assert_eq!(::std::mem::align_of::<elf64_note>(),
               4usize,
               concat!("Alignment of ", stringify!(elf64_note)));
    assert_eq!(unsafe { &(*(0 as *const elf64_note)).n_namesz as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_note),
                       "::",
                       stringify!(n_namesz)));
    assert_eq!(unsafe { &(*(0 as *const elf64_note)).n_descsz as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_note),
                       "::",
                       stringify!(n_descsz)));
    assert_eq!(unsafe { &(*(0 as *const elf64_note)).n_type as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(elf64_note),
                       "::",
                       stringify!(n_type)));
}
impl Clone for elf64_note {
    fn clone(&self) -> Self {
        *self
    }
}
pub type Elf64_Nhdr = elf64_note;
