/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 32;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _IOC_NRBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_TYPEBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZEBITS: ::std::os::raw::c_uint = 14;
pub const _IOC_DIRBITS: ::std::os::raw::c_uint = 2;
pub const _IOC_NRMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_TYPEMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_SIZEMASK: ::std::os::raw::c_uint = 16383;
pub const _IOC_DIRMASK: ::std::os::raw::c_uint = 3;
pub const _IOC_NRSHIFT: ::std::os::raw::c_uint = 0;
pub const _IOC_TYPESHIFT: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZESHIFT: ::std::os::raw::c_uint = 16;
pub const _IOC_DIRSHIFT: ::std::os::raw::c_uint = 30;
pub const _IOC_NONE: ::std::os::raw::c_uint = 0;
pub const _IOC_WRITE: ::std::os::raw::c_uint = 1;
pub const _IOC_READ: ::std::os::raw::c_uint = 2;
pub const IOC_IN: ::std::os::raw::c_uint = 1073741824;
pub const IOC_OUT: ::std::os::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::std::os::raw::c_uint = 3221225472;
pub const IOCSIZE_MASK: ::std::os::raw::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: ::std::os::raw::c_uint = 16;
pub const PSCI_0_2_FN_BASE: ::std::os::raw::c_uint = 2214592512;
pub const PSCI_0_2_64BIT: ::std::os::raw::c_uint = 1073741824;
pub const PSCI_0_2_FN64_BASE: ::std::os::raw::c_uint = 3288334336;
pub const PSCI_0_2_POWER_STATE_ID_MASK: ::std::os::raw::c_uint = 65535;
pub const PSCI_0_2_POWER_STATE_ID_SHIFT: ::std::os::raw::c_uint = 0;
pub const PSCI_0_2_POWER_STATE_TYPE_SHIFT: ::std::os::raw::c_uint = 16;
pub const PSCI_0_2_POWER_STATE_TYPE_MASK: ::std::os::raw::c_uint = 65536;
pub const PSCI_0_2_POWER_STATE_AFFL_SHIFT: ::std::os::raw::c_uint = 24;
pub const PSCI_0_2_POWER_STATE_AFFL_MASK: ::std::os::raw::c_uint = 50331648;
pub const PSCI_0_2_AFFINITY_LEVEL_ON: ::std::os::raw::c_uint = 0;
pub const PSCI_0_2_AFFINITY_LEVEL_OFF: ::std::os::raw::c_uint = 1;
pub const PSCI_0_2_AFFINITY_LEVEL_ON_PENDING: ::std::os::raw::c_uint = 2;
pub const PSCI_0_2_TOS_UP_MIGRATE: ::std::os::raw::c_uint = 0;
pub const PSCI_0_2_TOS_UP_NO_MIGRATE: ::std::os::raw::c_uint = 1;
pub const PSCI_0_2_TOS_MP: ::std::os::raw::c_uint = 2;
pub const PSCI_VERSION_MAJOR_SHIFT: ::std::os::raw::c_uint = 16;
pub const PSCI_VERSION_MINOR_MASK: ::std::os::raw::c_uint = 65535;
pub const PSCI_VERSION_MAJOR_MASK: ::std::os::raw::c_int = -65536;
pub const PSCI_RET_SUCCESS: ::std::os::raw::c_uint = 0;
pub const PSCI_RET_NOT_SUPPORTED: ::std::os::raw::c_int = -1;
pub const PSCI_RET_INVALID_PARAMS: ::std::os::raw::c_int = -2;
pub const PSCI_RET_DENIED: ::std::os::raw::c_int = -3;
pub const PSCI_RET_ALREADY_ON: ::std::os::raw::c_int = -4;
pub const PSCI_RET_ON_PENDING: ::std::os::raw::c_int = -5;
pub const PSCI_RET_INTERNAL_FAILURE: ::std::os::raw::c_int = -6;
pub const PSCI_RET_NOT_PRESENT: ::std::os::raw::c_int = -7;
pub const PSCI_RET_DISABLED: ::std::os::raw::c_int = -8;
pub const HWCAP_SWP: ::std::os::raw::c_uint = 1;
pub const HWCAP_HALF: ::std::os::raw::c_uint = 2;
pub const HWCAP_THUMB: ::std::os::raw::c_uint = 4;
pub const HWCAP_26BIT: ::std::os::raw::c_uint = 8;
pub const HWCAP_FAST_MULT: ::std::os::raw::c_uint = 16;
pub const HWCAP_FPA: ::std::os::raw::c_uint = 32;
pub const HWCAP_VFP: ::std::os::raw::c_uint = 64;
pub const HWCAP_EDSP: ::std::os::raw::c_uint = 128;
pub const HWCAP_JAVA: ::std::os::raw::c_uint = 256;
pub const HWCAP_IWMMXT: ::std::os::raw::c_uint = 512;
pub const HWCAP_CRUNCH: ::std::os::raw::c_uint = 1024;
pub const HWCAP_THUMBEE: ::std::os::raw::c_uint = 2048;
pub const HWCAP_NEON: ::std::os::raw::c_uint = 4096;
pub const HWCAP_VFPv3: ::std::os::raw::c_uint = 8192;
pub const HWCAP_VFPv3D16: ::std::os::raw::c_uint = 16384;
pub const HWCAP_TLS: ::std::os::raw::c_uint = 32768;
pub const HWCAP_VFPv4: ::std::os::raw::c_uint = 65536;
pub const HWCAP_IDIVA: ::std::os::raw::c_uint = 131072;
pub const HWCAP_IDIVT: ::std::os::raw::c_uint = 262144;
pub const HWCAP_VFPD32: ::std::os::raw::c_uint = 524288;
pub const HWCAP_IDIV: ::std::os::raw::c_uint = 393216;
pub const HWCAP_LPAE: ::std::os::raw::c_uint = 1048576;
pub const HWCAP_EVTSTRM: ::std::os::raw::c_uint = 2097152;
pub const HWCAP2_AES: ::std::os::raw::c_uint = 1;
pub const HWCAP2_PMULL: ::std::os::raw::c_uint = 2;
pub const HWCAP2_SHA1: ::std::os::raw::c_uint = 4;
pub const HWCAP2_SHA2: ::std::os::raw::c_uint = 8;
pub const HWCAP2_CRC32: ::std::os::raw::c_uint = 16;
pub const PTRACE_GETREGS: ::std::os::raw::c_uint = 12;
pub const PTRACE_SETREGS: ::std::os::raw::c_uint = 13;
pub const PTRACE_GETFPREGS: ::std::os::raw::c_uint = 14;
pub const PTRACE_SETFPREGS: ::std::os::raw::c_uint = 15;
pub const PTRACE_GETWMMXREGS: ::std::os::raw::c_uint = 18;
pub const PTRACE_SETWMMXREGS: ::std::os::raw::c_uint = 19;
pub const PTRACE_OLDSETOPTIONS: ::std::os::raw::c_uint = 21;
pub const PTRACE_GET_THREAD_AREA: ::std::os::raw::c_uint = 22;
pub const PTRACE_SET_SYSCALL: ::std::os::raw::c_uint = 23;
pub const PTRACE_GETCRUNCHREGS: ::std::os::raw::c_uint = 25;
pub const PTRACE_SETCRUNCHREGS: ::std::os::raw::c_uint = 26;
pub const PTRACE_GETVFPREGS: ::std::os::raw::c_uint = 27;
pub const PTRACE_SETVFPREGS: ::std::os::raw::c_uint = 28;
pub const PTRACE_GETHBPREGS: ::std::os::raw::c_uint = 29;
pub const PTRACE_SETHBPREGS: ::std::os::raw::c_uint = 30;
pub const USR26_MODE: ::std::os::raw::c_uint = 0;
pub const FIQ26_MODE: ::std::os::raw::c_uint = 1;
pub const IRQ26_MODE: ::std::os::raw::c_uint = 2;
pub const SVC26_MODE: ::std::os::raw::c_uint = 3;
pub const USR_MODE: ::std::os::raw::c_uint = 16;
pub const SVC_MODE: ::std::os::raw::c_uint = 19;
pub const FIQ_MODE: ::std::os::raw::c_uint = 17;
pub const IRQ_MODE: ::std::os::raw::c_uint = 18;
pub const ABT_MODE: ::std::os::raw::c_uint = 23;
pub const HYP_MODE: ::std::os::raw::c_uint = 26;
pub const UND_MODE: ::std::os::raw::c_uint = 27;
pub const SYSTEM_MODE: ::std::os::raw::c_uint = 31;
pub const MODE32_BIT: ::std::os::raw::c_uint = 16;
pub const MODE_MASK: ::std::os::raw::c_uint = 31;
pub const V4_PSR_T_BIT: ::std::os::raw::c_uint = 32;
pub const V7M_PSR_T_BIT: ::std::os::raw::c_uint = 16777216;
pub const PSR_T_BIT: ::std::os::raw::c_uint = 32;
pub const PSR_F_BIT: ::std::os::raw::c_uint = 64;
pub const PSR_I_BIT: ::std::os::raw::c_uint = 128;
pub const PSR_A_BIT: ::std::os::raw::c_uint = 256;
pub const PSR_E_BIT: ::std::os::raw::c_uint = 512;
pub const PSR_J_BIT: ::std::os::raw::c_uint = 16777216;
pub const PSR_Q_BIT: ::std::os::raw::c_uint = 134217728;
pub const PSR_V_BIT: ::std::os::raw::c_uint = 268435456;
pub const PSR_C_BIT: ::std::os::raw::c_uint = 536870912;
pub const PSR_Z_BIT: ::std::os::raw::c_uint = 1073741824;
pub const PSR_N_BIT: ::std::os::raw::c_uint = 2147483648;
pub const PSR_f: ::std::os::raw::c_uint = 4278190080;
pub const PSR_s: ::std::os::raw::c_uint = 16711680;
pub const PSR_x: ::std::os::raw::c_uint = 65280;
pub const PSR_c: ::std::os::raw::c_uint = 255;
pub const APSR_MASK: ::std::os::raw::c_uint = 4161732608;
pub const PSR_ISET_MASK: ::std::os::raw::c_uint = 16777232;
pub const PSR_IT_MASK: ::std::os::raw::c_uint = 100727808;
pub const PSR_ENDIAN_MASK: ::std::os::raw::c_uint = 512;
pub const PSR_ENDSTATE: ::std::os::raw::c_uint = 0;
pub const PT_TEXT_ADDR: ::std::os::raw::c_uint = 65536;
pub const PT_DATA_ADDR: ::std::os::raw::c_uint = 65540;
pub const PT_TEXT_END_ADDR: ::std::os::raw::c_uint = 65544;
pub const ARM_VFPREGS_SIZE: ::std::os::raw::c_uint = 260;
pub const KVM_ARM_TARGET_CORTEX_A15: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_TARGET_CORTEX_A7: ::std::os::raw::c_uint = 1;
pub const KVM_ARM_NUM_TARGETS: ::std::os::raw::c_uint = 2;
pub const KVM_ARM_DEVICE_TYPE_SHIFT: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_DEVICE_TYPE_MASK: ::std::os::raw::c_uint = 65535;
pub const KVM_ARM_DEVICE_ID_SHIFT: ::std::os::raw::c_uint = 16;
pub const KVM_ARM_DEVICE_ID_MASK: ::std::os::raw::c_uint = 4294901760;
pub const KVM_ARM_DEVICE_VGIC_V2: ::std::os::raw::c_uint = 0;
pub const KVM_VGIC_V2_ADDR_TYPE_DIST: ::std::os::raw::c_uint = 0;
pub const KVM_VGIC_V2_ADDR_TYPE_CPU: ::std::os::raw::c_uint = 1;
pub const KVM_VGIC_V2_DIST_SIZE: ::std::os::raw::c_uint = 4096;
pub const KVM_VGIC_V2_CPU_SIZE: ::std::os::raw::c_uint = 8192;
pub const KVM_ARM_VCPU_POWER_OFF: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_VCPU_PSCI_0_2: ::std::os::raw::c_uint = 1;
pub const KVM_REG_ARM_COPROC_MASK: ::std::os::raw::c_uint = 268369920;
pub const KVM_REG_ARM_COPROC_SHIFT: ::std::os::raw::c_uint = 16;
pub const KVM_REG_ARM_32_OPC2_MASK: ::std::os::raw::c_uint = 7;
pub const KVM_REG_ARM_32_OPC2_SHIFT: ::std::os::raw::c_uint = 0;
pub const KVM_REG_ARM_OPC1_MASK: ::std::os::raw::c_uint = 120;
pub const KVM_REG_ARM_OPC1_SHIFT: ::std::os::raw::c_uint = 3;
pub const KVM_REG_ARM_CRM_MASK: ::std::os::raw::c_uint = 1920;
pub const KVM_REG_ARM_CRM_SHIFT: ::std::os::raw::c_uint = 7;
pub const KVM_REG_ARM_32_CRN_MASK: ::std::os::raw::c_uint = 30720;
pub const KVM_REG_ARM_32_CRN_SHIFT: ::std::os::raw::c_uint = 11;
pub const KVM_REG_ARM_CORE: ::std::os::raw::c_uint = 1048576;
pub const KVM_REG_ARM_DEMUX: ::std::os::raw::c_uint = 1114112;
pub const KVM_REG_ARM_DEMUX_ID_MASK: ::std::os::raw::c_uint = 65280;
pub const KVM_REG_ARM_DEMUX_ID_SHIFT: ::std::os::raw::c_uint = 8;
pub const KVM_REG_ARM_DEMUX_ID_CCSIDR: ::std::os::raw::c_uint = 0;
pub const KVM_REG_ARM_DEMUX_VAL_MASK: ::std::os::raw::c_uint = 255;
pub const KVM_REG_ARM_DEMUX_VAL_SHIFT: ::std::os::raw::c_uint = 0;
pub const KVM_REG_ARM_VFP: ::std::os::raw::c_uint = 1179648;
pub const KVM_REG_ARM_VFP_MASK: ::std::os::raw::c_uint = 65535;
pub const KVM_REG_ARM_VFP_BASE_REG: ::std::os::raw::c_uint = 0;
pub const KVM_REG_ARM_VFP_FPSID: ::std::os::raw::c_uint = 4096;
pub const KVM_REG_ARM_VFP_FPSCR: ::std::os::raw::c_uint = 4097;
pub const KVM_REG_ARM_VFP_MVFR1: ::std::os::raw::c_uint = 4102;
pub const KVM_REG_ARM_VFP_MVFR0: ::std::os::raw::c_uint = 4103;
pub const KVM_REG_ARM_VFP_FPEXC: ::std::os::raw::c_uint = 4104;
pub const KVM_REG_ARM_VFP_FPINST: ::std::os::raw::c_uint = 4105;
pub const KVM_REG_ARM_VFP_FPINST2: ::std::os::raw::c_uint = 4106;
pub const KVM_DEV_ARM_VGIC_GRP_ADDR: ::std::os::raw::c_uint = 0;
pub const KVM_DEV_ARM_VGIC_GRP_DIST_REGS: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_ARM_VGIC_GRP_CPU_REGS: ::std::os::raw::c_uint = 2;
pub const KVM_DEV_ARM_VGIC_CPUID_SHIFT: ::std::os::raw::c_uint = 32;
pub const KVM_DEV_ARM_VGIC_CPUID_MASK: ::std::os::raw::c_ulonglong =
    1095216660480;
pub const KVM_DEV_ARM_VGIC_OFFSET_SHIFT: ::std::os::raw::c_uint = 0;
pub const KVM_DEV_ARM_VGIC_OFFSET_MASK: ::std::os::raw::c_uint = 4294967295;
pub const KVM_DEV_ARM_VGIC_GRP_NR_IRQS: ::std::os::raw::c_uint = 3;
pub const KVM_DEV_ARM_VGIC_GRP_CTRL: ::std::os::raw::c_uint = 4;
pub const KVM_DEV_ARM_VGIC_CTRL_INIT: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_IRQ_TYPE_SHIFT: ::std::os::raw::c_uint = 24;
pub const KVM_ARM_IRQ_TYPE_MASK: ::std::os::raw::c_uint = 255;
pub const KVM_ARM_IRQ_VCPU_SHIFT: ::std::os::raw::c_uint = 16;
pub const KVM_ARM_IRQ_VCPU_MASK: ::std::os::raw::c_uint = 255;
pub const KVM_ARM_IRQ_NUM_SHIFT: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_IRQ_NUM_MASK: ::std::os::raw::c_uint = 65535;
pub const KVM_ARM_IRQ_TYPE_CPU: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_IRQ_TYPE_SPI: ::std::os::raw::c_uint = 1;
pub const KVM_ARM_IRQ_TYPE_PPI: ::std::os::raw::c_uint = 2;
pub const KVM_ARM_IRQ_CPU_IRQ: ::std::os::raw::c_uint = 0;
pub const KVM_ARM_IRQ_CPU_FIQ: ::std::os::raw::c_uint = 1;
pub const KVM_ARM_IRQ_GIC_MAX: ::std::os::raw::c_uint = 127;
pub const KVM_PSCI_FN_BASE: ::std::os::raw::c_uint = 2512501342;
pub const KVM_PSCI_RET_SUCCESS: ::std::os::raw::c_uint = 0;
pub const KVM_PSCI_RET_NI: ::std::os::raw::c_int = -1;
pub const KVM_PSCI_RET_INVAL: ::std::os::raw::c_int = -2;
pub const KVM_PSCI_RET_DENIED: ::std::os::raw::c_int = -3;
pub const KVM_API_VERSION: ::std::os::raw::c_uint = 12;
pub const KVM_TRC_SHIFT: ::std::os::raw::c_uint = 16;
pub const KVM_TRC_ENTRYEXIT: ::std::os::raw::c_uint = 65536;
pub const KVM_TRC_HANDLER: ::std::os::raw::c_uint = 131072;
pub const KVM_TRC_VMENTRY: ::std::os::raw::c_uint = 65537;
pub const KVM_TRC_VMEXIT: ::std::os::raw::c_uint = 65538;
pub const KVM_TRC_PAGE_FAULT: ::std::os::raw::c_uint = 131073;
pub const KVM_TRC_HEAD_SIZE: ::std::os::raw::c_uint = 12;
pub const KVM_TRC_CYCLE_SIZE: ::std::os::raw::c_uint = 8;
pub const KVM_TRC_EXTRA_MAX: ::std::os::raw::c_uint = 7;
pub const KVM_TRC_INJ_VIRQ: ::std::os::raw::c_uint = 131074;
pub const KVM_TRC_REDELIVER_EVT: ::std::os::raw::c_uint = 131075;
pub const KVM_TRC_PEND_INTR: ::std::os::raw::c_uint = 131076;
pub const KVM_TRC_IO_READ: ::std::os::raw::c_uint = 131077;
pub const KVM_TRC_IO_WRITE: ::std::os::raw::c_uint = 131078;
pub const KVM_TRC_CR_READ: ::std::os::raw::c_uint = 131079;
pub const KVM_TRC_CR_WRITE: ::std::os::raw::c_uint = 131080;
pub const KVM_TRC_DR_READ: ::std::os::raw::c_uint = 131081;
pub const KVM_TRC_DR_WRITE: ::std::os::raw::c_uint = 131082;
pub const KVM_TRC_MSR_READ: ::std::os::raw::c_uint = 131083;
pub const KVM_TRC_MSR_WRITE: ::std::os::raw::c_uint = 131084;
pub const KVM_TRC_CPUID: ::std::os::raw::c_uint = 131085;
pub const KVM_TRC_INTR: ::std::os::raw::c_uint = 131086;
pub const KVM_TRC_NMI: ::std::os::raw::c_uint = 131087;
pub const KVM_TRC_VMMCALL: ::std::os::raw::c_uint = 131088;
pub const KVM_TRC_HLT: ::std::os::raw::c_uint = 131089;
pub const KVM_TRC_CLTS: ::std::os::raw::c_uint = 131090;
pub const KVM_TRC_LMSW: ::std::os::raw::c_uint = 131091;
pub const KVM_TRC_APIC_ACCESS: ::std::os::raw::c_uint = 131092;
pub const KVM_TRC_TDP_FAULT: ::std::os::raw::c_uint = 131093;
pub const KVM_TRC_GTLB_WRITE: ::std::os::raw::c_uint = 131094;
pub const KVM_TRC_STLB_WRITE: ::std::os::raw::c_uint = 131095;
pub const KVM_TRC_STLB_INVAL: ::std::os::raw::c_uint = 131096;
pub const KVM_TRC_PPC_INSTR: ::std::os::raw::c_uint = 131097;
pub const KVM_MEM_LOG_DIRTY_PAGES: ::std::os::raw::c_uint = 1;
pub const KVM_MEM_READONLY: ::std::os::raw::c_uint = 2;
pub const KVM_PIT_SPEAKER_DUMMY: ::std::os::raw::c_uint = 1;
pub const KVM_EXIT_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const KVM_EXIT_EXCEPTION: ::std::os::raw::c_uint = 1;
pub const KVM_EXIT_IO: ::std::os::raw::c_uint = 2;
pub const KVM_EXIT_HYPERCALL: ::std::os::raw::c_uint = 3;
pub const KVM_EXIT_DEBUG: ::std::os::raw::c_uint = 4;
pub const KVM_EXIT_HLT: ::std::os::raw::c_uint = 5;
pub const KVM_EXIT_MMIO: ::std::os::raw::c_uint = 6;
pub const KVM_EXIT_IRQ_WINDOW_OPEN: ::std::os::raw::c_uint = 7;
pub const KVM_EXIT_SHUTDOWN: ::std::os::raw::c_uint = 8;
pub const KVM_EXIT_FAIL_ENTRY: ::std::os::raw::c_uint = 9;
pub const KVM_EXIT_INTR: ::std::os::raw::c_uint = 10;
pub const KVM_EXIT_SET_TPR: ::std::os::raw::c_uint = 11;
pub const KVM_EXIT_TPR_ACCESS: ::std::os::raw::c_uint = 12;
pub const KVM_EXIT_S390_SIEIC: ::std::os::raw::c_uint = 13;
pub const KVM_EXIT_S390_RESET: ::std::os::raw::c_uint = 14;
pub const KVM_EXIT_DCR: ::std::os::raw::c_uint = 15;
pub const KVM_EXIT_NMI: ::std::os::raw::c_uint = 16;
pub const KVM_EXIT_INTERNAL_ERROR: ::std::os::raw::c_uint = 17;
pub const KVM_EXIT_OSI: ::std::os::raw::c_uint = 18;
pub const KVM_EXIT_PAPR_HCALL: ::std::os::raw::c_uint = 19;
pub const KVM_EXIT_S390_UCONTROL: ::std::os::raw::c_uint = 20;
pub const KVM_EXIT_WATCHDOG: ::std::os::raw::c_uint = 21;
pub const KVM_EXIT_S390_TSCH: ::std::os::raw::c_uint = 22;
pub const KVM_EXIT_EPR: ::std::os::raw::c_uint = 23;
pub const KVM_EXIT_SYSTEM_EVENT: ::std::os::raw::c_uint = 24;
pub const KVM_INTERNAL_ERROR_EMULATION: ::std::os::raw::c_uint = 1;
pub const KVM_INTERNAL_ERROR_SIMUL_EX: ::std::os::raw::c_uint = 2;
pub const KVM_INTERNAL_ERROR_DELIVERY_EV: ::std::os::raw::c_uint = 3;
pub const KVM_EXIT_IO_IN: ::std::os::raw::c_uint = 0;
pub const KVM_S390_RESET_POR: ::std::os::raw::c_uint = 1;
pub const KVM_S390_RESET_CLEAR: ::std::os::raw::c_uint = 2;
pub const KVM_S390_RESET_SUBSYSTEM: ::std::os::raw::c_uint = 4;
pub const KVM_S390_RESET_CPU_INIT: ::std::os::raw::c_uint = 8;
pub const KVM_SYSTEM_EVENT_SHUTDOWN: ::std::os::raw::c_uint = 1;
pub const KVM_MP_STATE_RUNNABLE: ::std::os::raw::c_uint = 0;
pub const KVM_MP_STATE_UNINITIALIZED: ::std::os::raw::c_uint = 1;
pub const KVM_MP_STATE_INIT_RECEIVED: ::std::os::raw::c_uint = 2;
pub const KVM_MP_STATE_HALTED: ::std::os::raw::c_uint = 3;
pub const KVM_MP_STATE_SIPI_RECEIVED: ::std::os::raw::c_uint = 4;
pub const KVM_MP_STATE_STOPPED: ::std::os::raw::c_uint = 5;
pub const KVM_MP_STATE_CHECK_STOP: ::std::os::raw::c_uint = 6;
pub const KVM_MP_STATE_OPERATING: ::std::os::raw::c_uint = 7;
pub const KVM_MP_STATE_LOAD: ::std::os::raw::c_uint = 8;
pub const KVM_S390_SIGP_STOP: ::std::os::raw::c_uint = 4294836224;
pub const KVM_S390_PROGRAM_INT: ::std::os::raw::c_uint = 4294836225;
pub const KVM_S390_SIGP_SET_PREFIX: ::std::os::raw::c_uint = 4294836226;
pub const KVM_S390_RESTART: ::std::os::raw::c_uint = 4294836227;
pub const KVM_S390_INT_PFAULT_INIT: ::std::os::raw::c_uint = 4294836228;
pub const KVM_S390_INT_PFAULT_DONE: ::std::os::raw::c_uint = 4294836229;
pub const KVM_S390_MCHK: ::std::os::raw::c_uint = 4294840320;
pub const KVM_S390_INT_CLOCK_COMP: ::std::os::raw::c_uint = 4294905860;
pub const KVM_S390_INT_CPU_TIMER: ::std::os::raw::c_uint = 4294905861;
pub const KVM_S390_INT_VIRTIO: ::std::os::raw::c_uint = 4294911491;
pub const KVM_S390_INT_SERVICE: ::std::os::raw::c_uint = 4294910977;
pub const KVM_S390_INT_EMERGENCY: ::std::os::raw::c_uint = 4294906369;
pub const KVM_S390_INT_EXTERNAL_CALL: ::std::os::raw::c_uint = 4294906370;
pub const KVM_S390_INT_IO_MIN: ::std::os::raw::c_uint = 0;
pub const KVM_S390_INT_IO_MAX: ::std::os::raw::c_uint = 4294836223;
pub const KVM_S390_STOP_FLAG_STORE_STATUS: ::std::os::raw::c_uint = 1;
pub const KVM_GUESTDBG_ENABLE: ::std::os::raw::c_uint = 1;
pub const KVM_GUESTDBG_SINGLESTEP: ::std::os::raw::c_uint = 2;
pub const KVM_PPC_PAGE_SIZES_MAX_SZ: ::std::os::raw::c_uint = 8;
pub const KVM_PPC_PAGE_SIZES_REAL: ::std::os::raw::c_uint = 1;
pub const KVM_PPC_1T_SEGMENTS: ::std::os::raw::c_uint = 2;
pub const KVM_PPC_PVINFO_FLAGS_EV_IDLE: ::std::os::raw::c_uint = 1;
pub const KVMIO: ::std::os::raw::c_uint = 174;
pub const KVM_VM_S390_UCONTROL: ::std::os::raw::c_uint = 1;
pub const KVM_VM_PPC_HV: ::std::os::raw::c_uint = 1;
pub const KVM_VM_PPC_PR: ::std::os::raw::c_uint = 2;
pub const KVM_S390_SIE_PAGE_OFFSET: ::std::os::raw::c_uint = 1;
pub const KVM_CAP_IRQCHIP: ::std::os::raw::c_uint = 0;
pub const KVM_CAP_HLT: ::std::os::raw::c_uint = 1;
pub const KVM_CAP_MMU_SHADOW_CACHE_CONTROL: ::std::os::raw::c_uint = 2;
pub const KVM_CAP_USER_MEMORY: ::std::os::raw::c_uint = 3;
pub const KVM_CAP_SET_TSS_ADDR: ::std::os::raw::c_uint = 4;
pub const KVM_CAP_VAPIC: ::std::os::raw::c_uint = 6;
pub const KVM_CAP_EXT_CPUID: ::std::os::raw::c_uint = 7;
pub const KVM_CAP_CLOCKSOURCE: ::std::os::raw::c_uint = 8;
pub const KVM_CAP_NR_VCPUS: ::std::os::raw::c_uint = 9;
pub const KVM_CAP_NR_MEMSLOTS: ::std::os::raw::c_uint = 10;
pub const KVM_CAP_PIT: ::std::os::raw::c_uint = 11;
pub const KVM_CAP_NOP_IO_DELAY: ::std::os::raw::c_uint = 12;
pub const KVM_CAP_PV_MMU: ::std::os::raw::c_uint = 13;
pub const KVM_CAP_MP_STATE: ::std::os::raw::c_uint = 14;
pub const KVM_CAP_COALESCED_MMIO: ::std::os::raw::c_uint = 15;
pub const KVM_CAP_SYNC_MMU: ::std::os::raw::c_uint = 16;
pub const KVM_CAP_IOMMU: ::std::os::raw::c_uint = 18;
pub const KVM_CAP_DESTROY_MEMORY_REGION_WORKS: ::std::os::raw::c_uint = 21;
pub const KVM_CAP_USER_NMI: ::std::os::raw::c_uint = 22;
pub const KVM_CAP_SET_GUEST_DEBUG: ::std::os::raw::c_uint = 23;
pub const KVM_CAP_IRQ_ROUTING: ::std::os::raw::c_uint = 25;
pub const KVM_CAP_IRQ_INJECT_STATUS: ::std::os::raw::c_uint = 26;
pub const KVM_CAP_ASSIGN_DEV_IRQ: ::std::os::raw::c_uint = 29;
pub const KVM_CAP_JOIN_MEMORY_REGIONS_WORKS: ::std::os::raw::c_uint = 30;
pub const KVM_CAP_IRQFD: ::std::os::raw::c_uint = 32;
pub const KVM_CAP_SET_BOOT_CPU_ID: ::std::os::raw::c_uint = 34;
pub const KVM_CAP_IOEVENTFD: ::std::os::raw::c_uint = 36;
pub const KVM_CAP_SET_IDENTITY_MAP_ADDR: ::std::os::raw::c_uint = 37;
pub const KVM_CAP_ADJUST_CLOCK: ::std::os::raw::c_uint = 39;
pub const KVM_CAP_INTERNAL_ERROR_DATA: ::std::os::raw::c_uint = 40;
pub const KVM_CAP_S390_PSW: ::std::os::raw::c_uint = 42;
pub const KVM_CAP_PPC_SEGSTATE: ::std::os::raw::c_uint = 43;
pub const KVM_CAP_HYPERV: ::std::os::raw::c_uint = 44;
pub const KVM_CAP_HYPERV_VAPIC: ::std::os::raw::c_uint = 45;
pub const KVM_CAP_HYPERV_SPIN: ::std::os::raw::c_uint = 46;
pub const KVM_CAP_PCI_SEGMENT: ::std::os::raw::c_uint = 47;
pub const KVM_CAP_PPC_PAIRED_SINGLES: ::std::os::raw::c_uint = 48;
pub const KVM_CAP_INTR_SHADOW: ::std::os::raw::c_uint = 49;
pub const KVM_CAP_X86_ROBUST_SINGLESTEP: ::std::os::raw::c_uint = 51;
pub const KVM_CAP_PPC_OSI: ::std::os::raw::c_uint = 52;
pub const KVM_CAP_PPC_UNSET_IRQ: ::std::os::raw::c_uint = 53;
pub const KVM_CAP_ENABLE_CAP: ::std::os::raw::c_uint = 54;
pub const KVM_CAP_PPC_GET_PVINFO: ::std::os::raw::c_uint = 57;
pub const KVM_CAP_PPC_IRQ_LEVEL: ::std::os::raw::c_uint = 58;
pub const KVM_CAP_ASYNC_PF: ::std::os::raw::c_uint = 59;
pub const KVM_CAP_TSC_CONTROL: ::std::os::raw::c_uint = 60;
pub const KVM_CAP_GET_TSC_KHZ: ::std::os::raw::c_uint = 61;
pub const KVM_CAP_PPC_BOOKE_SREGS: ::std::os::raw::c_uint = 62;
pub const KVM_CAP_SPAPR_TCE: ::std::os::raw::c_uint = 63;
pub const KVM_CAP_PPC_SMT: ::std::os::raw::c_uint = 64;
pub const KVM_CAP_PPC_RMA: ::std::os::raw::c_uint = 65;
pub const KVM_CAP_MAX_VCPUS: ::std::os::raw::c_uint = 66;
pub const KVM_CAP_PPC_HIOR: ::std::os::raw::c_uint = 67;
pub const KVM_CAP_PPC_PAPR: ::std::os::raw::c_uint = 68;
pub const KVM_CAP_SW_TLB: ::std::os::raw::c_uint = 69;
pub const KVM_CAP_ONE_REG: ::std::os::raw::c_uint = 70;
pub const KVM_CAP_S390_GMAP: ::std::os::raw::c_uint = 71;
pub const KVM_CAP_TSC_DEADLINE_TIMER: ::std::os::raw::c_uint = 72;
pub const KVM_CAP_S390_UCONTROL: ::std::os::raw::c_uint = 73;
pub const KVM_CAP_SYNC_REGS: ::std::os::raw::c_uint = 74;
pub const KVM_CAP_PCI_2_3: ::std::os::raw::c_uint = 75;
pub const KVM_CAP_KVMCLOCK_CTRL: ::std::os::raw::c_uint = 76;
pub const KVM_CAP_SIGNAL_MSI: ::std::os::raw::c_uint = 77;
pub const KVM_CAP_PPC_GET_SMMU_INFO: ::std::os::raw::c_uint = 78;
pub const KVM_CAP_S390_COW: ::std::os::raw::c_uint = 79;
pub const KVM_CAP_PPC_ALLOC_HTAB: ::std::os::raw::c_uint = 80;
pub const KVM_CAP_READONLY_MEM: ::std::os::raw::c_uint = 81;
pub const KVM_CAP_IRQFD_RESAMPLE: ::std::os::raw::c_uint = 82;
pub const KVM_CAP_PPC_BOOKE_WATCHDOG: ::std::os::raw::c_uint = 83;
pub const KVM_CAP_PPC_HTAB_FD: ::std::os::raw::c_uint = 84;
pub const KVM_CAP_S390_CSS_SUPPORT: ::std::os::raw::c_uint = 85;
pub const KVM_CAP_PPC_EPR: ::std::os::raw::c_uint = 86;
pub const KVM_CAP_ARM_PSCI: ::std::os::raw::c_uint = 87;
pub const KVM_CAP_ARM_SET_DEVICE_ADDR: ::std::os::raw::c_uint = 88;
pub const KVM_CAP_DEVICE_CTRL: ::std::os::raw::c_uint = 89;
pub const KVM_CAP_IRQ_MPIC: ::std::os::raw::c_uint = 90;
pub const KVM_CAP_PPC_RTAS: ::std::os::raw::c_uint = 91;
pub const KVM_CAP_IRQ_XICS: ::std::os::raw::c_uint = 92;
pub const KVM_CAP_ARM_EL1_32BIT: ::std::os::raw::c_uint = 93;
pub const KVM_CAP_SPAPR_MULTITCE: ::std::os::raw::c_uint = 94;
pub const KVM_CAP_EXT_EMUL_CPUID: ::std::os::raw::c_uint = 95;
pub const KVM_CAP_HYPERV_TIME: ::std::os::raw::c_uint = 96;
pub const KVM_CAP_IOAPIC_POLARITY_IGNORED: ::std::os::raw::c_uint = 97;
pub const KVM_CAP_ENABLE_CAP_VM: ::std::os::raw::c_uint = 98;
pub const KVM_CAP_S390_IRQCHIP: ::std::os::raw::c_uint = 99;
pub const KVM_CAP_IOEVENTFD_NO_LENGTH: ::std::os::raw::c_uint = 100;
pub const KVM_CAP_VM_ATTRIBUTES: ::std::os::raw::c_uint = 101;
pub const KVM_CAP_ARM_PSCI_0_2: ::std::os::raw::c_uint = 102;
pub const KVM_CAP_PPC_FIXUP_HCALL: ::std::os::raw::c_uint = 103;
pub const KVM_CAP_PPC_ENABLE_HCALL: ::std::os::raw::c_uint = 104;
pub const KVM_CAP_CHECK_EXTENSION_VM: ::std::os::raw::c_uint = 105;
pub const KVM_CAP_S390_USER_SIGP: ::std::os::raw::c_uint = 106;
pub const KVM_IRQ_ROUTING_IRQCHIP: ::std::os::raw::c_uint = 1;
pub const KVM_IRQ_ROUTING_MSI: ::std::os::raw::c_uint = 2;
pub const KVM_IRQ_ROUTING_S390_ADAPTER: ::std::os::raw::c_uint = 3;
pub const KVM_IRQFD_FLAG_DEASSIGN: ::std::os::raw::c_uint = 1;
pub const KVM_IRQFD_FLAG_RESAMPLE: ::std::os::raw::c_uint = 2;
pub const KVM_MMU_FSL_BOOKE_NOHV: ::std::os::raw::c_uint = 0;
pub const KVM_MMU_FSL_BOOKE_HV: ::std::os::raw::c_uint = 1;
pub const KVM_REG_ARCH_MASK: ::std::os::raw::c_longlong = -72057594037927936;
pub const KVM_REG_GENERIC: ::std::os::raw::c_uint = 0;
pub const KVM_REG_PPC: ::std::os::raw::c_ulonglong = 1152921504606846976;
pub const KVM_REG_X86: ::std::os::raw::c_ulonglong = 2305843009213693952;
pub const KVM_REG_IA64: ::std::os::raw::c_ulonglong = 3458764513820540928;
pub const KVM_REG_ARM: ::std::os::raw::c_ulonglong = 4611686018427387904;
pub const KVM_REG_S390: ::std::os::raw::c_ulonglong = 5764607523034234880;
pub const KVM_REG_ARM64: ::std::os::raw::c_ulonglong = 6917529027641081856;
pub const KVM_REG_MIPS: ::std::os::raw::c_ulonglong = 8070450532247928832;
pub const KVM_REG_SIZE_SHIFT: ::std::os::raw::c_uint = 52;
pub const KVM_REG_SIZE_MASK: ::std::os::raw::c_ulonglong = 67553994410557440;
pub const KVM_REG_SIZE_U8: ::std::os::raw::c_uint = 0;
pub const KVM_REG_SIZE_U16: ::std::os::raw::c_ulonglong = 4503599627370496;
pub const KVM_REG_SIZE_U32: ::std::os::raw::c_ulonglong = 9007199254740992;
pub const KVM_REG_SIZE_U64: ::std::os::raw::c_ulonglong = 13510798882111488;
pub const KVM_REG_SIZE_U128: ::std::os::raw::c_ulonglong = 18014398509481984;
pub const KVM_REG_SIZE_U256: ::std::os::raw::c_ulonglong = 22517998136852480;
pub const KVM_REG_SIZE_U512: ::std::os::raw::c_ulonglong = 27021597764222976;
pub const KVM_REG_SIZE_U1024: ::std::os::raw::c_ulonglong = 31525197391593472;
pub const KVM_CREATE_DEVICE_TEST: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_VFIO_GROUP: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_VFIO_GROUP_ADD: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_VFIO_GROUP_DEL: ::std::os::raw::c_uint = 2;
pub const KVM_S390_STORE_STATUS_NOADDR: ::std::os::raw::c_int = -1;
pub const KVM_S390_STORE_STATUS_PREFIXED: ::std::os::raw::c_int = -2;
pub const KVM_DEV_ASSIGN_ENABLE_IOMMU: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_ASSIGN_PCI_2_3: ::std::os::raw::c_uint = 2;
pub const KVM_DEV_ASSIGN_MASK_INTX: ::std::os::raw::c_uint = 4;
pub const KVM_DEV_IRQ_HOST_INTX: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_IRQ_HOST_MSI: ::std::os::raw::c_uint = 2;
pub const KVM_DEV_IRQ_HOST_MSIX: ::std::os::raw::c_uint = 4;
pub const KVM_DEV_IRQ_GUEST_INTX: ::std::os::raw::c_uint = 256;
pub const KVM_DEV_IRQ_GUEST_MSI: ::std::os::raw::c_uint = 512;
pub const KVM_DEV_IRQ_GUEST_MSIX: ::std::os::raw::c_uint = 1024;
pub const KVM_DEV_IRQ_HOST_MASK: ::std::os::raw::c_uint = 255;
pub const KVM_DEV_IRQ_GUEST_MASK: ::std::os::raw::c_uint = 65280;
pub const KVM_MAX_MSIX_PER_DEV: ::std::os::raw::c_uint = 256;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_mode_t = ::std::os::raw::c_ushort;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_ushort;
pub type __kernel_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_size_t = ::std::os::raw::c_uint;
pub type __kernel_ssize_t = ::std::os::raw::c_int;
pub type __kernel_ptrdiff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pt_regs {
    pub uregs: [::std::os::raw::c_long; 18usize],
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(::std::mem::size_of::<pt_regs>() , 144usize , concat ! (
               "Size of: " , stringify ! ( pt_regs ) ));
    assert_eq! (::std::mem::align_of::<pt_regs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pt_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pt_regs ) ) . uregs as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pt_regs ) , "::" ,
                stringify ! ( uregs ) ));
}
impl Clone for pt_regs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_regs {
    pub usr_regs: pt_regs,
    pub svc_regs: [::std::os::raw::c_ulong; 3usize],
    pub abt_regs: [::std::os::raw::c_ulong; 3usize],
    pub und_regs: [::std::os::raw::c_ulong; 3usize],
    pub irq_regs: [::std::os::raw::c_ulong; 3usize],
    pub fiq_regs: [::std::os::raw::c_ulong; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_regs() {
    assert_eq!(::std::mem::size_of::<kvm_regs>() , 304usize , concat ! (
               "Size of: " , stringify ! ( kvm_regs ) ));
    assert_eq! (::std::mem::align_of::<kvm_regs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . usr_regs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( usr_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . svc_regs as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( svc_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . abt_regs as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( abt_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . und_regs as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( und_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . irq_regs as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( irq_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . fiq_regs as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( fiq_regs ) ));
}
impl Clone for kvm_regs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vcpu_init {
    pub target: __u32,
    pub features: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout_kvm_vcpu_init() {
    assert_eq!(::std::mem::size_of::<kvm_vcpu_init>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kvm_vcpu_init ) ));
    assert_eq! (::std::mem::align_of::<kvm_vcpu_init>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_vcpu_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_init ) ) . target as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_init ) , "::"
                , stringify ! ( target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_init ) ) . features as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_init ) , "::"
                , stringify ! ( features ) ));
}
impl Clone for kvm_vcpu_init {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_sregs {
}
#[test]
fn bindgen_test_layout_kvm_sregs() {
    assert_eq!(::std::mem::size_of::<kvm_sregs>() , 0usize , concat ! (
               "Size of: " , stringify ! ( kvm_sregs ) ));
    assert_eq! (::std::mem::align_of::<kvm_sregs>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_sregs ) ));
}
impl Clone for kvm_sregs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_fpu {
}
#[test]
fn bindgen_test_layout_kvm_fpu() {
    assert_eq!(::std::mem::size_of::<kvm_fpu>() , 0usize , concat ! (
               "Size of: " , stringify ! ( kvm_fpu ) ));
    assert_eq! (::std::mem::align_of::<kvm_fpu>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_fpu ) ));
}
impl Clone for kvm_fpu {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_guest_debug_arch {
}
#[test]
fn bindgen_test_layout_kvm_guest_debug_arch() {
    assert_eq!(::std::mem::size_of::<kvm_guest_debug_arch>() , 0usize , concat
               ! ( "Size of: " , stringify ! ( kvm_guest_debug_arch ) ));
    assert_eq! (::std::mem::align_of::<kvm_guest_debug_arch>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_guest_debug_arch ) ));
}
impl Clone for kvm_guest_debug_arch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_debug_exit_arch {
}
#[test]
fn bindgen_test_layout_kvm_debug_exit_arch() {
    assert_eq!(::std::mem::size_of::<kvm_debug_exit_arch>() , 0usize , concat
               ! ( "Size of: " , stringify ! ( kvm_debug_exit_arch ) ));
    assert_eq! (::std::mem::align_of::<kvm_debug_exit_arch>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_debug_exit_arch ) ));
}
impl Clone for kvm_debug_exit_arch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_sync_regs {
}
#[test]
fn bindgen_test_layout_kvm_sync_regs() {
    assert_eq!(::std::mem::size_of::<kvm_sync_regs>() , 0usize , concat ! (
               "Size of: " , stringify ! ( kvm_sync_regs ) ));
    assert_eq! (::std::mem::align_of::<kvm_sync_regs>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_sync_regs ) ));
}
impl Clone for kvm_sync_regs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_arch_memory_slot {
}
#[test]
fn bindgen_test_layout_kvm_arch_memory_slot() {
    assert_eq!(::std::mem::size_of::<kvm_arch_memory_slot>() , 0usize , concat
               ! ( "Size of: " , stringify ! ( kvm_arch_memory_slot ) ));
    assert_eq! (::std::mem::align_of::<kvm_arch_memory_slot>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_arch_memory_slot ) ));
}
impl Clone for kvm_arch_memory_slot {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_user_trace_setup {
    pub buf_size: __u32,
    pub buf_nr: __u32,
}
#[test]
fn bindgen_test_layout_kvm_user_trace_setup() {
    assert_eq!(::std::mem::size_of::<kvm_user_trace_setup>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( kvm_user_trace_setup ) ));
    assert_eq! (::std::mem::align_of::<kvm_user_trace_setup>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_user_trace_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_user_trace_setup ) ) . buf_size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_user_trace_setup )
                , "::" , stringify ! ( buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_user_trace_setup ) ) . buf_nr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_user_trace_setup )
                , "::" , stringify ! ( buf_nr ) ));
}
impl Clone for kvm_user_trace_setup {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_breakpoint {
    pub enabled: __u32,
    pub padding: __u32,
    pub address: __u64,
}
#[test]
fn bindgen_test_layout_kvm_breakpoint() {
    assert_eq!(::std::mem::size_of::<kvm_breakpoint>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_breakpoint ) ));
    assert_eq! (::std::mem::align_of::<kvm_breakpoint>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_breakpoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_breakpoint ) ) . enabled as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_breakpoint ) , "::"
                , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_breakpoint ) ) . padding as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_breakpoint ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_breakpoint ) ) . address as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_breakpoint ) , "::"
                , stringify ! ( address ) ));
}
impl Clone for kvm_breakpoint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_debug_guest {
    pub enabled: __u32,
    pub pad: __u32,
    pub breakpoints: [kvm_breakpoint; 4usize],
    pub singlestep: __u32,
}
#[test]
fn bindgen_test_layout_kvm_debug_guest() {
    assert_eq!(::std::mem::size_of::<kvm_debug_guest>() , 80usize , concat ! (
               "Size of: " , stringify ! ( kvm_debug_guest ) ));
    assert_eq! (::std::mem::align_of::<kvm_debug_guest>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_debug_guest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . enabled as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . breakpoints as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( breakpoints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . singlestep as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( singlestep ) ));
}
impl Clone for kvm_debug_guest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_memory_region {
    pub slot: __u32,
    pub flags: __u32,
    pub guest_phys_addr: __u64,
    pub memory_size: __u64,
}
#[test]
fn bindgen_test_layout_kvm_memory_region() {
    assert_eq!(::std::mem::size_of::<kvm_memory_region>() , 24usize , concat !
               ( "Size of: " , stringify ! ( kvm_memory_region ) ));
    assert_eq! (::std::mem::align_of::<kvm_memory_region>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_memory_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . slot as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . flags as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . guest_phys_addr
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . memory_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( memory_size ) ));
}
impl Clone for kvm_memory_region {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_userspace_memory_region {
    pub slot: __u32,
    pub flags: __u32,
    pub guest_phys_addr: __u64,
    pub memory_size: __u64,
    pub userspace_addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_userspace_memory_region() {
    assert_eq!(::std::mem::size_of::<kvm_userspace_memory_region>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_userspace_memory_region ) ));
    assert_eq! (::std::mem::align_of::<kvm_userspace_memory_region>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_userspace_memory_region )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) . slot as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! ( slot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) . flags
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) .
                guest_phys_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! (
                guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) .
                memory_size as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! (
                memory_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) .
                userspace_addr as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! (
                userspace_addr ) ));
}
impl Clone for kvm_userspace_memory_region {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_level {
    pub __bindgen_anon_1: kvm_irq_level__bindgen_ty_1,
    pub level: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_level__bindgen_ty_1 {
    pub irq: __BindgenUnionField<__u32>,
    pub status: __BindgenUnionField<__s32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_level__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_irq_level__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_irq_level__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_level__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_irq_level__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_level__bindgen_ty_1 ) ) . irq as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_level__bindgen_ty_1 ) , "::" , stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_level__bindgen_ty_1 ) ) . status
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_level__bindgen_ty_1 ) , "::" , stringify ! ( status )
                ));
}
impl Clone for kvm_irq_level__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_irq_level() {
    assert_eq!(::std::mem::size_of::<kvm_irq_level>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_irq_level ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_level>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irq_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_level ) ) . level as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_level ) , "::"
                , stringify ! ( level ) ));
}
impl Clone for kvm_irq_level {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_irqchip {
    pub chip_id: __u32,
    pub pad: __u32,
    pub chip: kvm_irqchip__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_irqchip__bindgen_ty_1 {
    pub dummy: __BindgenUnionField<[::std::os::raw::c_char; 512usize]>,
    pub bindgen_union_field: [u8; 512usize],
}
#[test]
fn bindgen_test_layout_kvm_irqchip__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_irqchip__bindgen_ty_1>() , 512usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_irqchip__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_irqchip__bindgen_ty_1>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irqchip__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip__bindgen_ty_1 ) ) . dummy as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irqchip__bindgen_ty_1 ) , "::" , stringify ! ( dummy ) ));
}
impl Clone for kvm_irqchip__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_irqchip__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_kvm_irqchip() {
    assert_eq!(::std::mem::size_of::<kvm_irqchip>() , 520usize , concat ! (
               "Size of: " , stringify ! ( kvm_irqchip ) ));
    assert_eq! (::std::mem::align_of::<kvm_irqchip>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip ) ) . chip_id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqchip ) , "::" ,
                stringify ! ( chip_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqchip ) , "::" ,
                stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip ) ) . chip as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqchip ) , "::" ,
                stringify ! ( chip ) ));
}
impl Clone for kvm_irqchip {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_irqchip {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_pit_config {
    pub flags: __u32,
    pub pad: [__u32; 15usize],
}
#[test]
fn bindgen_test_layout_kvm_pit_config() {
    assert_eq!(::std::mem::size_of::<kvm_pit_config>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kvm_pit_config ) ));
    assert_eq! (::std::mem::align_of::<kvm_pit_config>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_pit_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_config ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_config ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_config ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_config ) , "::"
                , stringify ! ( pad ) ));
}
impl Clone for kvm_pit_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_run {
    pub request_interrupt_window: __u8,
    pub padding1: [__u8; 7usize],
    pub exit_reason: __u32,
    pub ready_for_interrupt_injection: __u8,
    pub if_flag: __u8,
    pub padding2: [__u8; 2usize],
    pub cr8: __u64,
    pub apic_base: __u64,
    pub __bindgen_anon_1: kvm_run__bindgen_ty_1,
    pub kvm_valid_regs: __u64,
    pub kvm_dirty_regs: __u64,
    pub s: kvm_run__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1 {
    pub hw: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_1>,
    pub fail_entry: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_2>,
    pub ex: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_3>,
    pub io: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_4>,
    pub debug: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_5>,
    pub mmio: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_6>,
    pub hypercall: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_7>,
    pub tpr_access: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_8>,
    pub s390_sieic: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_9>,
    pub s390_reset_flags: __BindgenUnionField<__u64>,
    pub s390_ucontrol: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_10>,
    pub dcr: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_11>,
    pub internal: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_12>,
    pub osi: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_13>,
    pub papr_hcall: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_14>,
    pub s390_tsch: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_15>,
    pub epr: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_16>,
    pub system_event: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_17>,
    pub padding: __BindgenUnionField<[::std::os::raw::c_char; 256usize]>,
    pub bindgen_union_field: [u64; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_1 {
    pub hardware_exit_reason: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_1 ) ) .
                hardware_exit_reason as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                hardware_exit_reason ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_2 {
    pub hardware_entry_failure_reason: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_2 ) ) .
                hardware_entry_failure_reason as * const _ as usize } , 0usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                hardware_entry_failure_reason ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_3 {
    pub exception: __u32,
    pub error_code: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_3>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_3 ) ) .
                exception as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_3 ) ) .
                error_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                error_code ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_4 {
    pub direction: __u8,
    pub size: __u8,
    pub port: __u16,
    pub count: __u32,
    pub data_offset: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_4>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_4
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                direction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                size as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                port as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                data_offset as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                data_offset ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_5 {
    pub arch: kvm_debug_exit_arch,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_5>() ,
               0usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_5
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_5>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_5 ) ) .
                arch as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                arch ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_6 {
    pub phys_addr: __u64,
    pub data: [__u8; 8usize],
    pub len: __u32,
    pub is_write: __u8,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_6>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_6
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_6>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                phys_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                len as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                is_write as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                is_write ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_7 {
    pub nr: __u64,
    pub args: [__u64; 6usize],
    pub ret: __u64,
    pub longmode: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_7>() ,
               72usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_7
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_7>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                nr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                args as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                ret as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                ret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                longmode as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                longmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                pad as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                pad ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_8 {
    pub rip: __u64,
    pub is_write: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_8>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_8
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_8>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_8 ) ) .
                rip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) , "::" , stringify ! (
                rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_8 ) ) .
                is_write as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) , "::" , stringify ! (
                is_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_8 ) ) .
                pad as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) , "::" , stringify ! (
                pad ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_9 {
    pub icptcode: __u8,
    pub ipa: __u16,
    pub ipb: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_9>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_9
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_9>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_9 ) ) .
                icptcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) , "::" , stringify ! (
                icptcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_9 ) ) .
                ipa as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) , "::" , stringify ! (
                ipa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_9 ) ) .
                ipb as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) , "::" , stringify ! (
                ipb ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_10 {
    pub trans_exc_code: __u64,
    pub pgm_code: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_10>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_10 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_10>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_10 ) )
                . trans_exc_code as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_10 ) , "::" , stringify ! (
                trans_exc_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_10 ) )
                . pgm_code as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_10 ) , "::" , stringify ! (
                pgm_code ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_11 {
    pub dcrn: __u32,
    pub data: __u32,
    pub is_write: __u8,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_11>() ,
               12usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_11 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_11>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_11 ) )
                . dcrn as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) , "::" , stringify ! (
                dcrn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_11 ) )
                . data as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_11 ) )
                . is_write as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) , "::" , stringify ! (
                is_write ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_12 {
    pub suberror: __u32,
    pub ndata: __u32,
    pub data: [__u64; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_12>() ,
               136usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_12 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_12>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_12 ) )
                . suberror as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) , "::" , stringify ! (
                suberror ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_12 ) )
                . ndata as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) , "::" , stringify ! (
                ndata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_12 ) )
                . data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) , "::" , stringify ! (
                data ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_13 {
    pub gprs: [__u64; 32usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_13>() ,
               256usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_13 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_13>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_13 ) )
                . gprs as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_13 ) , "::" , stringify ! (
                gprs ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_14 {
    pub nr: __u64,
    pub ret: __u64,
    pub args: [__u64; 9usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_14>() ,
               88usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_14 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_14>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_14 ) )
                . nr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) , "::" , stringify ! (
                nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_14 ) )
                . ret as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) , "::" , stringify ! (
                ret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_14 ) )
                . args as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) , "::" , stringify ! (
                args ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_15 {
    pub subchannel_id: __u16,
    pub subchannel_nr: __u16,
    pub io_int_parm: __u32,
    pub io_int_word: __u32,
    pub ipb: __u32,
    pub dequeued: __u8,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_15>() ,
               20usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_15 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_15>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . subchannel_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                subchannel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . subchannel_nr as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                subchannel_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . io_int_parm as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                io_int_parm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . io_int_word as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                io_int_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . ipb as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                ipb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . dequeued as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                dequeued ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_16 {
    pub epr: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_16>() ,
               4usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_16 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_16>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_16 ) )
                . epr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_16 ) , "::" , stringify ! (
                epr ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_17 {
    pub type_: __u32,
    pub flags: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_17>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_17 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_17>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_17 ) )
                . type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_17 ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_17 ) )
                . flags as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_17 ) , "::" , stringify ! (
                flags ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1>() , 256usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_run__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_run__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . hw as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( hw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . fail_entry as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( fail_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . ex as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( ex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . io as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . debug as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . mmio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( mmio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . hypercall as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( hypercall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . tpr_access as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( tpr_access ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . s390_sieic as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_sieic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) .
                s390_reset_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_reset_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . s390_ucontrol
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_ucontrol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . dcr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( dcr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . internal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . osi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( osi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . papr_hcall as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( papr_hcall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . s390_tsch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_tsch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . epr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( epr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . system_event
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( system_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . padding as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_run__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_run__bindgen_ty_2 {
    pub regs: __BindgenUnionField<kvm_sync_regs>,
    pub padding: __BindgenUnionField<[::std::os::raw::c_char; 1024usize]>,
    pub bindgen_union_field: [u8; 1024usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_2>() , 1024usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_run__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_2>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_run__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_2 ) ) . regs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_2 )
                , "::" , stringify ! ( regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_2 ) ) . padding as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_2 )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_run__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_run__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_kvm_run() {
    assert_eq!(::std::mem::size_of::<kvm_run>() , 1328usize , concat ! (
               "Size of: " , stringify ! ( kvm_run ) ));
    assert_eq! (::std::mem::align_of::<kvm_run>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_run ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . request_interrupt_window as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( request_interrupt_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . padding1 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . exit_reason as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( exit_reason ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) .
                ready_for_interrupt_injection as * const _ as usize } ,
                12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( ready_for_interrupt_injection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . if_flag as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( if_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . padding2 as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . cr8 as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( cr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . apic_base as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( apic_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . kvm_valid_regs as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( kvm_valid_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . kvm_dirty_regs as * const _
                as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( kvm_dirty_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . s as * const _ as usize } ,
                304usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( s ) ));
}
impl Clone for kvm_run {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_run {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_coalesced_mmio_zone {
    pub addr: __u64,
    pub size: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_coalesced_mmio_zone() {
    assert_eq!(::std::mem::size_of::<kvm_coalesced_mmio_zone>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_coalesced_mmio_zone ) ));
    assert_eq! (::std::mem::align_of::<kvm_coalesced_mmio_zone>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_coalesced_mmio_zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_zone ) ) . addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_zone
                ) , "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_zone ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_zone
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_zone ) ) . pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_zone
                ) , "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_coalesced_mmio_zone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_coalesced_mmio {
    pub phys_addr: __u64,
    pub len: __u32,
    pub pad: __u32,
    pub data: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_coalesced_mmio() {
    assert_eq!(::std::mem::size_of::<kvm_coalesced_mmio>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( kvm_coalesced_mmio ) ));
    assert_eq! (::std::mem::align_of::<kvm_coalesced_mmio>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_coalesced_mmio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . phys_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . pad as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for kvm_coalesced_mmio {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_coalesced_mmio_ring {
    pub first: __u32,
    pub last: __u32,
    pub coalesced_mmio: __IncompleteArrayField<kvm_coalesced_mmio>,
    pub __force_alignment: [u64; 0],
}
#[test]
fn bindgen_test_layout_kvm_coalesced_mmio_ring() {
    assert_eq!(::std::mem::size_of::<kvm_coalesced_mmio_ring>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_coalesced_mmio_ring ) ));
    assert_eq! (::std::mem::align_of::<kvm_coalesced_mmio_ring>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_coalesced_mmio_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_ring ) ) . first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_ring
                ) , "::" , stringify ! ( first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_ring ) ) . last as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_ring
                ) , "::" , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_ring ) ) .
                coalesced_mmio as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_ring
                ) , "::" , stringify ! ( coalesced_mmio ) ));
}
impl Clone for kvm_coalesced_mmio_ring {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_translation {
    pub linear_address: __u64,
    pub physical_address: __u64,
    pub valid: __u8,
    pub writeable: __u8,
    pub usermode: __u8,
    pub pad: [__u8; 5usize],
}
#[test]
fn bindgen_test_layout_kvm_translation() {
    assert_eq!(::std::mem::size_of::<kvm_translation>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_translation ) ));
    assert_eq! (::std::mem::align_of::<kvm_translation>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_translation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . linear_address as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( linear_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . physical_address as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( physical_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . valid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . writeable as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( writeable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . usermode as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( usermode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . pad as * const _ as
                usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_translation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_interrupt {
    pub irq: __u32,
}
#[test]
fn bindgen_test_layout_kvm_interrupt() {
    assert_eq!(::std::mem::size_of::<kvm_interrupt>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_interrupt ) ));
    assert_eq! (::std::mem::align_of::<kvm_interrupt>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_interrupt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_interrupt ) ) . irq as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_interrupt ) , "::"
                , stringify ! ( irq ) ));
}
impl Clone for kvm_interrupt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dirty_log {
    pub slot: __u32,
    pub padding1: __u32,
    pub __bindgen_anon_1: kvm_dirty_log__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dirty_log__bindgen_ty_1 {
    pub dirty_bitmap: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub padding2: __BindgenUnionField<__u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_kvm_dirty_log__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_dirty_log__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_dirty_log__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_dirty_log__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_dirty_log__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log__bindgen_ty_1 ) ) .
                dirty_bitmap as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_dirty_log__bindgen_ty_1 ) , "::" , stringify ! (
                dirty_bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log__bindgen_ty_1 ) ) .
                padding2 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_dirty_log__bindgen_ty_1 ) , "::" , stringify ! ( padding2
                ) ));
}
impl Clone for kvm_dirty_log__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_dirty_log() {
    assert_eq!(::std::mem::size_of::<kvm_dirty_log>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_dirty_log ) ));
    assert_eq! (::std::mem::align_of::<kvm_dirty_log>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_dirty_log ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log ) ) . slot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_log ) , "::"
                , stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log ) ) . padding1 as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_log ) , "::"
                , stringify ! ( padding1 ) ));
}
impl Clone for kvm_dirty_log {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_signal_mask {
    pub len: __u32,
    pub sigset: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_kvm_signal_mask() {
    assert_eq!(::std::mem::size_of::<kvm_signal_mask>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_signal_mask ) ));
    assert_eq! (::std::mem::align_of::<kvm_signal_mask>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_signal_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_signal_mask ) ) . len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_signal_mask ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_signal_mask ) ) . sigset as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_signal_mask ) ,
                "::" , stringify ! ( sigset ) ));
}
impl Clone for kvm_signal_mask {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_tpr_access_ctl {
    pub enabled: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_tpr_access_ctl() {
    assert_eq!(::std::mem::size_of::<kvm_tpr_access_ctl>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( kvm_tpr_access_ctl ) ));
    assert_eq! (::std::mem::align_of::<kvm_tpr_access_ctl>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_tpr_access_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_tpr_access_ctl ) ) . enabled as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_tpr_access_ctl ) ,
                "::" , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_tpr_access_ctl ) ) . flags as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_tpr_access_ctl ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_tpr_access_ctl ) ) . reserved as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_tpr_access_ctl ) ,
                "::" , stringify ! ( reserved ) ));
}
impl Clone for kvm_tpr_access_ctl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vapic_addr {
    pub vapic_addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_vapic_addr() {
    assert_eq!(::std::mem::size_of::<kvm_vapic_addr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_vapic_addr ) ));
    assert_eq! (::std::mem::align_of::<kvm_vapic_addr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_vapic_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vapic_addr ) ) . vapic_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vapic_addr ) , "::"
                , stringify ! ( vapic_addr ) ));
}
impl Clone for kvm_vapic_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_mp_state {
    pub mp_state: __u32,
}
#[test]
fn bindgen_test_layout_kvm_mp_state() {
    assert_eq!(::std::mem::size_of::<kvm_mp_state>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_mp_state ) ));
    assert_eq! (::std::mem::align_of::<kvm_mp_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_mp_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_mp_state ) ) . mp_state as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_mp_state ) , "::" ,
                stringify ! ( mp_state ) ));
}
impl Clone for kvm_mp_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_psw {
    pub mask: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_psw() {
    assert_eq!(::std::mem::size_of::<kvm_s390_psw>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_s390_psw ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_psw>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_s390_psw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_psw ) ) . mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_psw ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_psw ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_psw ) , "::" ,
                stringify ! ( addr ) ));
}
impl Clone for kvm_s390_psw {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_interrupt {
    pub type_: __u32,
    pub parm: __u32,
    pub parm64: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_interrupt() {
    assert_eq!(::std::mem::size_of::<kvm_s390_interrupt>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_interrupt ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_interrupt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_interrupt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_interrupt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_interrupt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_interrupt ) ) . parm as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_interrupt ) ,
                "::" , stringify ! ( parm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_interrupt ) ) . parm64 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_interrupt ) ,
                "::" , stringify ! ( parm64 ) ));
}
impl Clone for kvm_s390_interrupt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_io_info {
    pub subchannel_id: __u16,
    pub subchannel_nr: __u16,
    pub io_int_parm: __u32,
    pub io_int_word: __u32,
}
#[test]
fn bindgen_test_layout_kvm_s390_io_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_io_info>() , 12usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_io_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_io_info>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_s390_io_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . subchannel_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( subchannel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . subchannel_nr as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( subchannel_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . io_int_parm as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( io_int_parm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . io_int_word as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( io_int_word ) ));
}
impl Clone for kvm_s390_io_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_ext_info {
    pub ext_params: __u32,
    pub pad: __u32,
    pub ext_params2: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_ext_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_ext_info>() , 16usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_ext_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_ext_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_ext_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ext_info ) ) . ext_params as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ext_info ) ,
                "::" , stringify ! ( ext_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ext_info ) ) . pad as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ext_info ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ext_info ) ) . ext_params2 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ext_info ) ,
                "::" , stringify ! ( ext_params2 ) ));
}
impl Clone for kvm_s390_ext_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_pgm_info {
    pub trans_exc_code: __u64,
    pub mon_code: __u64,
    pub per_address: __u64,
    pub data_exc_code: __u32,
    pub code: __u16,
    pub mon_class_nr: __u16,
    pub per_code: __u8,
    pub per_atmid: __u8,
    pub exc_access_id: __u8,
    pub per_access_id: __u8,
    pub op_access_id: __u8,
    pub pad: [__u8; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_s390_pgm_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_pgm_info>() , 40usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_pgm_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_pgm_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_pgm_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . trans_exc_code as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( trans_exc_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . mon_code as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( mon_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_address as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . data_exc_code as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( data_exc_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . code as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . mon_class_nr as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( mon_class_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_code as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_atmid as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_atmid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . exc_access_id as
                * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( exc_access_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_access_id as
                * const _ as usize } , 35usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_access_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . op_access_id as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( op_access_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . pad as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_s390_pgm_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_prefix_info {
    pub address: __u32,
}
#[test]
fn bindgen_test_layout_kvm_s390_prefix_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_prefix_info>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_prefix_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_prefix_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_prefix_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_prefix_info ) ) . address as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_prefix_info )
                , "::" , stringify ! ( address ) ));
}
impl Clone for kvm_s390_prefix_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_extcall_info {
    pub code: __u16,
}
#[test]
fn bindgen_test_layout_kvm_s390_extcall_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_extcall_info>() , 2usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_s390_extcall_info )
               ));
    assert_eq! (::std::mem::align_of::<kvm_s390_extcall_info>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_extcall_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_extcall_info ) ) . code as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_extcall_info )
                , "::" , stringify ! ( code ) ));
}
impl Clone for kvm_s390_extcall_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_emerg_info {
    pub code: __u16,
}
#[test]
fn bindgen_test_layout_kvm_s390_emerg_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_emerg_info>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_emerg_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_emerg_info>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_emerg_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_emerg_info ) ) . code as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_emerg_info ) ,
                "::" , stringify ! ( code ) ));
}
impl Clone for kvm_s390_emerg_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_stop_info {
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_kvm_s390_stop_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_stop_info>() , 4usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_stop_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_stop_info>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_stop_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_stop_info ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_stop_info ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for kvm_s390_stop_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_mchk_info {
    pub cr14: __u64,
    pub mcic: __u64,
    pub failing_storage_address: __u64,
    pub ext_damage_code: __u32,
    pub pad: __u32,
    pub fixed_logout: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_s390_mchk_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_mchk_info>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_mchk_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_mchk_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_mchk_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . cr14 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( cr14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . mcic as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( mcic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) .
                failing_storage_address as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( failing_storage_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . ext_damage_code
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( ext_damage_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . pad as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . fixed_logout as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( fixed_logout ) ));
}
impl Clone for kvm_s390_mchk_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_irq {
    pub type_: __u64,
    pub u: kvm_s390_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_irq__bindgen_ty_1 {
    pub io: __BindgenUnionField<kvm_s390_io_info>,
    pub ext: __BindgenUnionField<kvm_s390_ext_info>,
    pub pgm: __BindgenUnionField<kvm_s390_pgm_info>,
    pub emerg: __BindgenUnionField<kvm_s390_emerg_info>,
    pub extcall: __BindgenUnionField<kvm_s390_extcall_info>,
    pub prefix: __BindgenUnionField<kvm_s390_prefix_info>,
    pub stop: __BindgenUnionField<kvm_s390_stop_info>,
    pub mchk: __BindgenUnionField<kvm_s390_mchk_info>,
    pub reserved: __BindgenUnionField<[::std::os::raw::c_char; 64usize]>,
    pub bindgen_union_field: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_s390_irq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_s390_irq__bindgen_ty_1>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_s390_irq__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_irq__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_s390_irq__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . io as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . ext as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . pgm as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( pgm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . emerg as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( emerg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . extcall
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( extcall )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . prefix
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( prefix )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . stop as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . mchk as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( mchk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( reserved )
                ));
}
impl Clone for kvm_s390_irq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_s390_irq() {
    assert_eq!(::std::mem::size_of::<kvm_s390_irq>() , 72usize , concat ! (
               "Size of: " , stringify ! ( kvm_s390_irq ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_irq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_s390_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_irq ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq ) ) . u as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_irq ) , "::" ,
                stringify ! ( u ) ));
}
impl Clone for kvm_s390_irq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_guest_debug {
    pub control: __u32,
    pub pad: __u32,
    pub arch: kvm_guest_debug_arch,
}
#[test]
fn bindgen_test_layout_kvm_guest_debug() {
    assert_eq!(::std::mem::size_of::<kvm_guest_debug>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_guest_debug ) ));
    assert_eq! (::std::mem::align_of::<kvm_guest_debug>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_guest_debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug ) ) . control as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug ) ,
                "::" , stringify ! ( control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug ) ) . arch as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug ) ,
                "::" , stringify ! ( arch ) ));
}
impl Clone for kvm_guest_debug {
    fn clone(&self) -> Self { *self }
}
pub const kvm_ioeventfd_flag_nr_datamatch: _bindgen_ty_1 = 0;
pub const kvm_ioeventfd_flag_nr_pio: _bindgen_ty_1 = 1;
pub const kvm_ioeventfd_flag_nr_deassign: _bindgen_ty_1 = 2;
pub const kvm_ioeventfd_flag_nr_virtio_ccw_notify: _bindgen_ty_1 = 3;
pub const kvm_ioeventfd_flag_nr_fast_mmio: _bindgen_ty_1 = 4;
pub const kvm_ioeventfd_flag_nr_max: _bindgen_ty_1 = 5;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
pub struct kvm_ioeventfd {
    pub datamatch: __u64,
    pub addr: __u64,
    pub len: __u32,
    pub fd: __s32,
    pub flags: __u32,
    pub pad: [__u8; 36usize],
}
#[test]
fn bindgen_test_layout_kvm_ioeventfd() {
    assert_eq!(::std::mem::size_of::<kvm_ioeventfd>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kvm_ioeventfd ) ));
    assert_eq! (::std::mem::align_of::<kvm_ioeventfd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_ioeventfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . datamatch as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( datamatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . fd as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . pad as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( pad ) ));
}
impl Default for kvm_ioeventfd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct kvm_enable_cap {
    pub cap: __u32,
    pub flags: __u32,
    pub args: [__u64; 4usize],
    pub pad: [__u8; 64usize],
}
#[test]
fn bindgen_test_layout_kvm_enable_cap() {
    assert_eq!(::std::mem::size_of::<kvm_enable_cap>() , 104usize , concat ! (
               "Size of: " , stringify ! ( kvm_enable_cap ) ));
    assert_eq! (::std::mem::align_of::<kvm_enable_cap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_enable_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . cap as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . args as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . pad as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( pad ) ));
}
impl Default for kvm_enable_cap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct kvm_ppc_pvinfo {
    pub flags: __u32,
    pub hcall: [__u32; 4usize],
    pub pad: [__u8; 108usize],
}
#[test]
fn bindgen_test_layout_kvm_ppc_pvinfo() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_pvinfo>() , 128usize , concat ! (
               "Size of: " , stringify ! ( kvm_ppc_pvinfo ) ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_pvinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_ppc_pvinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_pvinfo ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_pvinfo ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_pvinfo ) ) . hcall as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_pvinfo ) , "::"
                , stringify ! ( hcall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_pvinfo ) ) . pad as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_pvinfo ) , "::"
                , stringify ! ( pad ) ));
}
impl Default for kvm_ppc_pvinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ppc_one_page_size {
    pub page_shift: __u32,
    pub pte_enc: __u32,
}
#[test]
fn bindgen_test_layout_kvm_ppc_one_page_size() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_one_page_size>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_ppc_one_page_size )
               ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_one_page_size>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_ppc_one_page_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_page_size ) ) . page_shift as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_one_page_size )
                , "::" , stringify ! ( page_shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_page_size ) ) . pte_enc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_one_page_size )
                , "::" , stringify ! ( pte_enc ) ));
}
impl Clone for kvm_ppc_one_page_size {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ppc_one_seg_page_size {
    pub page_shift: __u32,
    pub slb_enc: __u32,
    pub enc: [kvm_ppc_one_page_size; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_ppc_one_seg_page_size() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_one_seg_page_size>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_ppc_one_seg_page_size ) ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_one_seg_page_size>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_ppc_one_seg_page_size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_seg_page_size ) ) .
                page_shift as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ppc_one_seg_page_size ) , "::" , stringify ! ( page_shift
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_seg_page_size ) ) . slb_enc
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ppc_one_seg_page_size ) , "::" , stringify ! ( slb_enc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_seg_page_size ) ) . enc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ppc_one_seg_page_size ) , "::" , stringify ! ( enc ) ));
}
impl Clone for kvm_ppc_one_seg_page_size {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ppc_smmu_info {
    pub flags: __u64,
    pub slb_size: __u32,
    pub pad: __u32,
    pub sps: [kvm_ppc_one_seg_page_size; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_ppc_smmu_info() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_smmu_info>() , 592usize , concat
               ! ( "Size of: " , stringify ! ( kvm_ppc_smmu_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_smmu_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_ppc_smmu_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . slb_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( slb_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . pad as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . sps as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( sps ) ));
}
impl Clone for kvm_ppc_smmu_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_irqchip {
    pub irqchip: __u32,
    pub pin: __u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_irqchip() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_irqchip>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing_irqchip ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_irqchip>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_irqchip ) ) . irqchip as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_irqchip
                ) , "::" , stringify ! ( irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_irqchip ) ) . pin as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_irqchip
                ) , "::" , stringify ! ( pin ) ));
}
impl Clone for kvm_irq_routing_irqchip {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_msi {
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_msi() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_msi>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( kvm_irq_routing_msi ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_msi>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . address_lo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( address_lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . address_hi as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( address_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . data as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . pad as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_irq_routing_msi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_s390_adapter {
    pub ind_addr: __u64,
    pub summary_addr: __u64,
    pub ind_offset: __u64,
    pub summary_offset: __u32,
    pub adapter_id: __u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_s390_adapter() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_s390_adapter>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing_s390_adapter ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_s390_adapter>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_s390_adapter )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                ind_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! ( ind_addr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                summary_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                summary_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                ind_offset as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                ind_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                summary_offset as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                summary_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                adapter_id as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                adapter_id ) ));
}
impl Clone for kvm_irq_routing_s390_adapter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_entry {
    pub gsi: __u32,
    pub type_: __u32,
    pub flags: __u32,
    pub pad: __u32,
    pub u: kvm_irq_routing_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_entry__bindgen_ty_1 {
    pub irqchip: __BindgenUnionField<kvm_irq_routing_irqchip>,
    pub msi: __BindgenUnionField<kvm_irq_routing_msi>,
    pub adapter: __BindgenUnionField<kvm_irq_routing_s390_adapter>,
    pub pad: __BindgenUnionField<[__u32; 8usize]>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_entry__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing_entry__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_entry__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                irqchip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                msi as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                adapter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                pad as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                pad ) ));
}
impl Clone for kvm_irq_routing_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_entry() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_entry>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_irq_routing_entry )
               ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . gsi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( gsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . type_ as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . u as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( u ) ));
}
impl Clone for kvm_irq_routing_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing {
    pub nr: __u32,
    pub flags: __u32,
    pub entries: __IncompleteArrayField<kvm_irq_routing_entry>,
    pub __force_alignment: [u64; 0],
}
#[test]
fn bindgen_test_layout_kvm_irq_routing() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_irq_routing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing ) ) . nr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing ) ,
                "::" , stringify ! ( nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing ) ) . entries as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing ) ,
                "::" , stringify ! ( entries ) ));
}
impl Clone for kvm_irq_routing {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irqfd {
    pub fd: __u32,
    pub gsi: __u32,
    pub flags: __u32,
    pub resamplefd: __u32,
    pub pad: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_irqfd() {
    assert_eq!(::std::mem::size_of::<kvm_irqfd>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kvm_irqfd ) ));
    assert_eq! (::std::mem::align_of::<kvm_irqfd>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irqfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . fd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . gsi as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( gsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . resamplefd as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( resamplefd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . pad as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for kvm_irqfd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_clock_data {
    pub clock: __u64,
    pub flags: __u32,
    pub pad: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_kvm_clock_data() {
    assert_eq!(::std::mem::size_of::<kvm_clock_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( kvm_clock_data ) ));
    assert_eq! (::std::mem::align_of::<kvm_clock_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_clock_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_clock_data ) ) . clock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_clock_data ) , "::"
                , stringify ! ( clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_clock_data ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_clock_data ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_clock_data ) ) . pad as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_clock_data ) , "::"
                , stringify ! ( pad ) ));
}
impl Clone for kvm_clock_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_config_tlb {
    pub params: __u64,
    pub array: __u64,
    pub mmu_type: __u32,
    pub array_len: __u32,
}
#[test]
fn bindgen_test_layout_kvm_config_tlb() {
    assert_eq!(::std::mem::size_of::<kvm_config_tlb>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_config_tlb ) ));
    assert_eq! (::std::mem::align_of::<kvm_config_tlb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_config_tlb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . params as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . array as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . mmu_type as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( mmu_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . array_len as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( array_len ) ));
}
impl Clone for kvm_config_tlb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dirty_tlb {
    pub bitmap: __u64,
    pub num_dirty: __u32,
}
#[test]
fn bindgen_test_layout_kvm_dirty_tlb() {
    assert_eq!(::std::mem::size_of::<kvm_dirty_tlb>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_dirty_tlb ) ));
    assert_eq! (::std::mem::align_of::<kvm_dirty_tlb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_dirty_tlb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_tlb ) ) . bitmap as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_tlb ) , "::"
                , stringify ! ( bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_tlb ) ) . num_dirty as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_tlb ) , "::"
                , stringify ! ( num_dirty ) ));
}
impl Clone for kvm_dirty_tlb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_reg_list {
    pub n: __u64,
    pub reg: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_kvm_reg_list() {
    assert_eq!(::std::mem::size_of::<kvm_reg_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_reg_list ) ));
    assert_eq! (::std::mem::align_of::<kvm_reg_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_reg_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_reg_list ) ) . n as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_reg_list ) , "::" ,
                stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_reg_list ) ) . reg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_reg_list ) , "::" ,
                stringify ! ( reg ) ));
}
impl Clone for kvm_reg_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_one_reg {
    pub id: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_one_reg() {
    assert_eq!(::std::mem::size_of::<kvm_one_reg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_one_reg ) ));
    assert_eq! (::std::mem::align_of::<kvm_one_reg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_one_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_one_reg ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_one_reg ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_one_reg ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_one_reg ) , "::" ,
                stringify ! ( addr ) ));
}
impl Clone for kvm_one_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_msi {
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
    pub flags: __u32,
    pub pad: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_msi() {
    assert_eq!(::std::mem::size_of::<kvm_msi>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kvm_msi ) ));
    assert_eq! (::std::mem::align_of::<kvm_msi>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . address_lo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( address_lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . address_hi as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( address_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . flags as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . pad as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for kvm_msi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_arm_device_addr {
    pub id: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_arm_device_addr() {
    assert_eq!(::std::mem::size_of::<kvm_arm_device_addr>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( kvm_arm_device_addr ) ));
    assert_eq! (::std::mem::align_of::<kvm_arm_device_addr>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_arm_device_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_arm_device_addr ) ) . id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_arm_device_addr ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_arm_device_addr ) ) . addr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_arm_device_addr ) ,
                "::" , stringify ! ( addr ) ));
}
impl Clone for kvm_arm_device_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_create_device {
    pub type_: __u32,
    pub fd: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_kvm_create_device() {
    assert_eq!(::std::mem::size_of::<kvm_create_device>() , 12usize , concat !
               ( "Size of: " , stringify ! ( kvm_create_device ) ));
    assert_eq! (::std::mem::align_of::<kvm_create_device>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_create_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_create_device ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_create_device ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_create_device ) ) . fd as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_create_device ) ,
                "::" , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_create_device ) ) . flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_create_device ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for kvm_create_device {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_device_attr {
    pub flags: __u32,
    pub group: __u32,
    pub attr: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_device_attr() {
    assert_eq!(::std::mem::size_of::<kvm_device_attr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_device_attr ) ));
    assert_eq! (::std::mem::align_of::<kvm_device_attr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_device_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . group as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . attr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( addr ) ));
}
impl Clone for kvm_device_attr {
    fn clone(&self) -> Self { *self }
}
pub const kvm_device_type_KVM_DEV_TYPE_FSL_MPIC_20: kvm_device_type = 1;
pub const kvm_device_type_KVM_DEV_TYPE_FSL_MPIC_42: kvm_device_type = 2;
pub const kvm_device_type_KVM_DEV_TYPE_XICS: kvm_device_type = 3;
pub const kvm_device_type_KVM_DEV_TYPE_VFIO: kvm_device_type = 4;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2: kvm_device_type = 5;
pub const kvm_device_type_KVM_DEV_TYPE_FLIC: kvm_device_type = 6;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V3: kvm_device_type = 7;
pub const kvm_device_type_KVM_DEV_TYPE_MAX: kvm_device_type = 8;
pub type kvm_device_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_ucas_mapping {
    pub user_addr: __u64,
    pub vcpu_addr: __u64,
    pub length: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_ucas_mapping() {
    assert_eq!(::std::mem::size_of::<kvm_s390_ucas_mapping>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_s390_ucas_mapping )
               ));
    assert_eq! (::std::mem::align_of::<kvm_s390_ucas_mapping>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_ucas_mapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ucas_mapping ) ) . user_addr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ucas_mapping )
                , "::" , stringify ! ( user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ucas_mapping ) ) . vcpu_addr as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ucas_mapping )
                , "::" , stringify ! ( vcpu_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ucas_mapping ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ucas_mapping )
                , "::" , stringify ! ( length ) ));
}
impl Clone for kvm_s390_ucas_mapping {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_pci_dev {
    pub assigned_dev_id: __u32,
    pub busnr: __u32,
    pub devfn: __u32,
    pub flags: __u32,
    pub segnr: __u32,
    pub __bindgen_anon_1: kvm_assigned_pci_dev__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_pci_dev__bindgen_ty_1 {
    pub reserved: __BindgenUnionField<[__u32; 11usize]>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_kvm_assigned_pci_dev__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_pci_dev__bindgen_ty_1>() ,
               44usize , concat ! (
               "Size of: " , stringify ! ( kvm_assigned_pci_dev__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_pci_dev__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_assigned_pci_dev__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_assigned_pci_dev__bindgen_ty_1 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for kvm_assigned_pci_dev__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_assigned_pci_dev() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_pci_dev>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_assigned_pci_dev )
               ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_pci_dev>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_pci_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) .
                assigned_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . busnr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( busnr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . devfn as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( devfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . flags as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . segnr as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( segnr ) ));
}
impl Clone for kvm_assigned_pci_dev {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_irq {
    pub assigned_dev_id: __u32,
    pub host_irq: __u32,
    pub guest_irq: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: kvm_assigned_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_irq__bindgen_ty_1 {
    pub reserved: __BindgenUnionField<[__u32; 12usize]>,
    pub bindgen_union_field: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_kvm_assigned_irq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_irq__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( kvm_assigned_irq__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_irq__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_irq__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_assigned_irq__bindgen_ty_1 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for kvm_assigned_irq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_assigned_irq() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_irq>() , 64usize , concat !
               ( "Size of: " , stringify ! ( kvm_assigned_irq ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_irq>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_assigned_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . assigned_dev_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . host_irq as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( host_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . guest_irq as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( guest_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . flags as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for kvm_assigned_irq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_msix_nr {
    pub assigned_dev_id: __u32,
    pub entry_nr: __u16,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_kvm_assigned_msix_nr() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_msix_nr>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( kvm_assigned_msix_nr ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_msix_nr>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_msix_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_nr ) ) .
                assigned_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_nr )
                , "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_nr ) ) . entry_nr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_nr )
                , "::" , stringify ! ( entry_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_nr ) ) . padding as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_nr )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_assigned_msix_nr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_msix_entry {
    pub assigned_dev_id: __u32,
    pub gsi: __u32,
    pub entry: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_assigned_msix_entry() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_msix_entry>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_assigned_msix_entry ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_msix_entry>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_msix_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) .
                assigned_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) . gsi as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( gsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) . entry as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) . padding as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_assigned_msix_entry {
    fn clone(&self) -> Self { *self }
}
