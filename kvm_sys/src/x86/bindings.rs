/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _IOC_NRBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_TYPEBITS: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZEBITS: ::std::os::raw::c_uint = 14;
pub const _IOC_DIRBITS: ::std::os::raw::c_uint = 2;
pub const _IOC_NRMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_TYPEMASK: ::std::os::raw::c_uint = 255;
pub const _IOC_SIZEMASK: ::std::os::raw::c_uint = 16383;
pub const _IOC_DIRMASK: ::std::os::raw::c_uint = 3;
pub const _IOC_NRSHIFT: ::std::os::raw::c_uint = 0;
pub const _IOC_TYPESHIFT: ::std::os::raw::c_uint = 8;
pub const _IOC_SIZESHIFT: ::std::os::raw::c_uint = 16;
pub const _IOC_DIRSHIFT: ::std::os::raw::c_uint = 30;
pub const _IOC_NONE: ::std::os::raw::c_uint = 0;
pub const _IOC_WRITE: ::std::os::raw::c_uint = 1;
pub const _IOC_READ: ::std::os::raw::c_uint = 2;
pub const IOC_IN: ::std::os::raw::c_uint = 1073741824;
pub const IOC_OUT: ::std::os::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::std::os::raw::c_uint = 3221225472;
pub const IOCSIZE_MASK: ::std::os::raw::c_uint = 1073676288;
pub const IOCSIZE_SHIFT: ::std::os::raw::c_uint = 16;
pub const DE_VECTOR: ::std::os::raw::c_uint = 0;
pub const DB_VECTOR: ::std::os::raw::c_uint = 1;
pub const BP_VECTOR: ::std::os::raw::c_uint = 3;
pub const OF_VECTOR: ::std::os::raw::c_uint = 4;
pub const BR_VECTOR: ::std::os::raw::c_uint = 5;
pub const UD_VECTOR: ::std::os::raw::c_uint = 6;
pub const NM_VECTOR: ::std::os::raw::c_uint = 7;
pub const DF_VECTOR: ::std::os::raw::c_uint = 8;
pub const TS_VECTOR: ::std::os::raw::c_uint = 10;
pub const NP_VECTOR: ::std::os::raw::c_uint = 11;
pub const SS_VECTOR: ::std::os::raw::c_uint = 12;
pub const GP_VECTOR: ::std::os::raw::c_uint = 13;
pub const PF_VECTOR: ::std::os::raw::c_uint = 14;
pub const MF_VECTOR: ::std::os::raw::c_uint = 16;
pub const AC_VECTOR: ::std::os::raw::c_uint = 17;
pub const MC_VECTOR: ::std::os::raw::c_uint = 18;
pub const XM_VECTOR: ::std::os::raw::c_uint = 19;
pub const VE_VECTOR: ::std::os::raw::c_uint = 20;
pub const KVM_NR_INTERRUPTS: ::std::os::raw::c_uint = 256;
pub const KVM_IOAPIC_NUM_PINS: ::std::os::raw::c_uint = 24;
pub const KVM_IRQCHIP_PIC_MASTER: ::std::os::raw::c_uint = 0;
pub const KVM_IRQCHIP_PIC_SLAVE: ::std::os::raw::c_uint = 1;
pub const KVM_IRQCHIP_IOAPIC: ::std::os::raw::c_uint = 2;
pub const KVM_NR_IRQCHIPS: ::std::os::raw::c_uint = 3;
pub const KVM_APIC_REG_SIZE: ::std::os::raw::c_uint = 1024;
pub const KVM_GUESTDBG_USE_SW_BP: ::std::os::raw::c_uint = 65536;
pub const KVM_GUESTDBG_USE_HW_BP: ::std::os::raw::c_uint = 131072;
pub const KVM_GUESTDBG_INJECT_DB: ::std::os::raw::c_uint = 262144;
pub const KVM_GUESTDBG_INJECT_BP: ::std::os::raw::c_uint = 524288;
pub const KVM_PIT_FLAGS_HPET_LEGACY: ::std::os::raw::c_uint = 1;
pub const KVM_VCPUEVENT_VALID_NMI_PENDING: ::std::os::raw::c_uint = 1;
pub const KVM_VCPUEVENT_VALID_SIPI_VECTOR: ::std::os::raw::c_uint = 2;
pub const KVM_VCPUEVENT_VALID_SHADOW: ::std::os::raw::c_uint = 4;
pub const KVM_X86_SHADOW_INT_MOV_SS: ::std::os::raw::c_uint = 1;
pub const KVM_X86_SHADOW_INT_STI: ::std::os::raw::c_uint = 2;
pub const KVM_MAX_XCRS: ::std::os::raw::c_uint = 16;
pub const KVM_API_VERSION: ::std::os::raw::c_uint = 12;
pub const KVM_TRC_SHIFT: ::std::os::raw::c_uint = 16;
pub const KVM_TRC_ENTRYEXIT: ::std::os::raw::c_uint = 65536;
pub const KVM_TRC_HANDLER: ::std::os::raw::c_uint = 131072;
pub const KVM_TRC_VMENTRY: ::std::os::raw::c_uint = 65537;
pub const KVM_TRC_VMEXIT: ::std::os::raw::c_uint = 65538;
pub const KVM_TRC_PAGE_FAULT: ::std::os::raw::c_uint = 131073;
pub const KVM_TRC_HEAD_SIZE: ::std::os::raw::c_uint = 12;
pub const KVM_TRC_CYCLE_SIZE: ::std::os::raw::c_uint = 8;
pub const KVM_TRC_EXTRA_MAX: ::std::os::raw::c_uint = 7;
pub const KVM_TRC_INJ_VIRQ: ::std::os::raw::c_uint = 131074;
pub const KVM_TRC_REDELIVER_EVT: ::std::os::raw::c_uint = 131075;
pub const KVM_TRC_PEND_INTR: ::std::os::raw::c_uint = 131076;
pub const KVM_TRC_IO_READ: ::std::os::raw::c_uint = 131077;
pub const KVM_TRC_IO_WRITE: ::std::os::raw::c_uint = 131078;
pub const KVM_TRC_CR_READ: ::std::os::raw::c_uint = 131079;
pub const KVM_TRC_CR_WRITE: ::std::os::raw::c_uint = 131080;
pub const KVM_TRC_DR_READ: ::std::os::raw::c_uint = 131081;
pub const KVM_TRC_DR_WRITE: ::std::os::raw::c_uint = 131082;
pub const KVM_TRC_MSR_READ: ::std::os::raw::c_uint = 131083;
pub const KVM_TRC_MSR_WRITE: ::std::os::raw::c_uint = 131084;
pub const KVM_TRC_CPUID: ::std::os::raw::c_uint = 131085;
pub const KVM_TRC_INTR: ::std::os::raw::c_uint = 131086;
pub const KVM_TRC_NMI: ::std::os::raw::c_uint = 131087;
pub const KVM_TRC_VMMCALL: ::std::os::raw::c_uint = 131088;
pub const KVM_TRC_HLT: ::std::os::raw::c_uint = 131089;
pub const KVM_TRC_CLTS: ::std::os::raw::c_uint = 131090;
pub const KVM_TRC_LMSW: ::std::os::raw::c_uint = 131091;
pub const KVM_TRC_APIC_ACCESS: ::std::os::raw::c_uint = 131092;
pub const KVM_TRC_TDP_FAULT: ::std::os::raw::c_uint = 131093;
pub const KVM_TRC_GTLB_WRITE: ::std::os::raw::c_uint = 131094;
pub const KVM_TRC_STLB_WRITE: ::std::os::raw::c_uint = 131095;
pub const KVM_TRC_STLB_INVAL: ::std::os::raw::c_uint = 131096;
pub const KVM_TRC_PPC_INSTR: ::std::os::raw::c_uint = 131097;
pub const KVM_MEM_LOG_DIRTY_PAGES: ::std::os::raw::c_uint = 1;
pub const KVM_MEM_READONLY: ::std::os::raw::c_uint = 2;
pub const KVM_PIT_SPEAKER_DUMMY: ::std::os::raw::c_uint = 1;
pub const KVM_EXIT_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const KVM_EXIT_EXCEPTION: ::std::os::raw::c_uint = 1;
pub const KVM_EXIT_IO: ::std::os::raw::c_uint = 2;
pub const KVM_EXIT_HYPERCALL: ::std::os::raw::c_uint = 3;
pub const KVM_EXIT_DEBUG: ::std::os::raw::c_uint = 4;
pub const KVM_EXIT_HLT: ::std::os::raw::c_uint = 5;
pub const KVM_EXIT_MMIO: ::std::os::raw::c_uint = 6;
pub const KVM_EXIT_IRQ_WINDOW_OPEN: ::std::os::raw::c_uint = 7;
pub const KVM_EXIT_SHUTDOWN: ::std::os::raw::c_uint = 8;
pub const KVM_EXIT_FAIL_ENTRY: ::std::os::raw::c_uint = 9;
pub const KVM_EXIT_INTR: ::std::os::raw::c_uint = 10;
pub const KVM_EXIT_SET_TPR: ::std::os::raw::c_uint = 11;
pub const KVM_EXIT_TPR_ACCESS: ::std::os::raw::c_uint = 12;
pub const KVM_EXIT_S390_SIEIC: ::std::os::raw::c_uint = 13;
pub const KVM_EXIT_S390_RESET: ::std::os::raw::c_uint = 14;
pub const KVM_EXIT_DCR: ::std::os::raw::c_uint = 15;
pub const KVM_EXIT_NMI: ::std::os::raw::c_uint = 16;
pub const KVM_EXIT_INTERNAL_ERROR: ::std::os::raw::c_uint = 17;
pub const KVM_EXIT_OSI: ::std::os::raw::c_uint = 18;
pub const KVM_EXIT_PAPR_HCALL: ::std::os::raw::c_uint = 19;
pub const KVM_EXIT_S390_UCONTROL: ::std::os::raw::c_uint = 20;
pub const KVM_EXIT_WATCHDOG: ::std::os::raw::c_uint = 21;
pub const KVM_EXIT_S390_TSCH: ::std::os::raw::c_uint = 22;
pub const KVM_EXIT_EPR: ::std::os::raw::c_uint = 23;
pub const KVM_EXIT_SYSTEM_EVENT: ::std::os::raw::c_uint = 24;
pub const KVM_INTERNAL_ERROR_EMULATION: ::std::os::raw::c_uint = 1;
pub const KVM_INTERNAL_ERROR_SIMUL_EX: ::std::os::raw::c_uint = 2;
pub const KVM_INTERNAL_ERROR_DELIVERY_EV: ::std::os::raw::c_uint = 3;
pub const KVM_EXIT_IO_IN: ::std::os::raw::c_uint = 0;
pub const KVM_S390_RESET_POR: ::std::os::raw::c_uint = 1;
pub const KVM_S390_RESET_CLEAR: ::std::os::raw::c_uint = 2;
pub const KVM_S390_RESET_SUBSYSTEM: ::std::os::raw::c_uint = 4;
pub const KVM_S390_RESET_CPU_INIT: ::std::os::raw::c_uint = 8;
pub const KVM_SYSTEM_EVENT_SHUTDOWN: ::std::os::raw::c_uint = 1;
pub const KVM_MP_STATE_RUNNABLE: ::std::os::raw::c_uint = 0;
pub const KVM_MP_STATE_UNINITIALIZED: ::std::os::raw::c_uint = 1;
pub const KVM_MP_STATE_INIT_RECEIVED: ::std::os::raw::c_uint = 2;
pub const KVM_MP_STATE_HALTED: ::std::os::raw::c_uint = 3;
pub const KVM_MP_STATE_SIPI_RECEIVED: ::std::os::raw::c_uint = 4;
pub const KVM_MP_STATE_STOPPED: ::std::os::raw::c_uint = 5;
pub const KVM_MP_STATE_CHECK_STOP: ::std::os::raw::c_uint = 6;
pub const KVM_MP_STATE_OPERATING: ::std::os::raw::c_uint = 7;
pub const KVM_MP_STATE_LOAD: ::std::os::raw::c_uint = 8;
pub const KVM_S390_SIGP_STOP: ::std::os::raw::c_uint = 4294836224;
pub const KVM_S390_PROGRAM_INT: ::std::os::raw::c_uint = 4294836225;
pub const KVM_S390_SIGP_SET_PREFIX: ::std::os::raw::c_uint = 4294836226;
pub const KVM_S390_RESTART: ::std::os::raw::c_uint = 4294836227;
pub const KVM_S390_INT_PFAULT_INIT: ::std::os::raw::c_uint = 4294836228;
pub const KVM_S390_INT_PFAULT_DONE: ::std::os::raw::c_uint = 4294836229;
pub const KVM_S390_MCHK: ::std::os::raw::c_uint = 4294840320;
pub const KVM_S390_INT_CLOCK_COMP: ::std::os::raw::c_uint = 4294905860;
pub const KVM_S390_INT_CPU_TIMER: ::std::os::raw::c_uint = 4294905861;
pub const KVM_S390_INT_VIRTIO: ::std::os::raw::c_uint = 4294911491;
pub const KVM_S390_INT_SERVICE: ::std::os::raw::c_uint = 4294910977;
pub const KVM_S390_INT_EMERGENCY: ::std::os::raw::c_uint = 4294906369;
pub const KVM_S390_INT_EXTERNAL_CALL: ::std::os::raw::c_uint = 4294906370;
pub const KVM_S390_INT_IO_MIN: ::std::os::raw::c_uint = 0;
pub const KVM_S390_INT_IO_MAX: ::std::os::raw::c_uint = 4294836223;
pub const KVM_S390_STOP_FLAG_STORE_STATUS: ::std::os::raw::c_uint = 1;
pub const KVM_GUESTDBG_ENABLE: ::std::os::raw::c_uint = 1;
pub const KVM_GUESTDBG_SINGLESTEP: ::std::os::raw::c_uint = 2;
pub const KVM_PPC_PAGE_SIZES_MAX_SZ: ::std::os::raw::c_uint = 8;
pub const KVM_PPC_PAGE_SIZES_REAL: ::std::os::raw::c_uint = 1;
pub const KVM_PPC_1T_SEGMENTS: ::std::os::raw::c_uint = 2;
pub const KVM_PPC_PVINFO_FLAGS_EV_IDLE: ::std::os::raw::c_uint = 1;
pub const KVMIO: ::std::os::raw::c_uint = 174;
pub const KVM_VM_S390_UCONTROL: ::std::os::raw::c_uint = 1;
pub const KVM_VM_PPC_HV: ::std::os::raw::c_uint = 1;
pub const KVM_VM_PPC_PR: ::std::os::raw::c_uint = 2;
pub const KVM_S390_SIE_PAGE_OFFSET: ::std::os::raw::c_uint = 1;
pub const KVM_CAP_IRQCHIP: ::std::os::raw::c_uint = 0;
pub const KVM_CAP_HLT: ::std::os::raw::c_uint = 1;
pub const KVM_CAP_MMU_SHADOW_CACHE_CONTROL: ::std::os::raw::c_uint = 2;
pub const KVM_CAP_USER_MEMORY: ::std::os::raw::c_uint = 3;
pub const KVM_CAP_SET_TSS_ADDR: ::std::os::raw::c_uint = 4;
pub const KVM_CAP_VAPIC: ::std::os::raw::c_uint = 6;
pub const KVM_CAP_EXT_CPUID: ::std::os::raw::c_uint = 7;
pub const KVM_CAP_CLOCKSOURCE: ::std::os::raw::c_uint = 8;
pub const KVM_CAP_NR_VCPUS: ::std::os::raw::c_uint = 9;
pub const KVM_CAP_NR_MEMSLOTS: ::std::os::raw::c_uint = 10;
pub const KVM_CAP_PIT: ::std::os::raw::c_uint = 11;
pub const KVM_CAP_NOP_IO_DELAY: ::std::os::raw::c_uint = 12;
pub const KVM_CAP_PV_MMU: ::std::os::raw::c_uint = 13;
pub const KVM_CAP_MP_STATE: ::std::os::raw::c_uint = 14;
pub const KVM_CAP_COALESCED_MMIO: ::std::os::raw::c_uint = 15;
pub const KVM_CAP_SYNC_MMU: ::std::os::raw::c_uint = 16;
pub const KVM_CAP_IOMMU: ::std::os::raw::c_uint = 18;
pub const KVM_CAP_DESTROY_MEMORY_REGION_WORKS: ::std::os::raw::c_uint = 21;
pub const KVM_CAP_USER_NMI: ::std::os::raw::c_uint = 22;
pub const KVM_CAP_SET_GUEST_DEBUG: ::std::os::raw::c_uint = 23;
pub const KVM_CAP_REINJECT_CONTROL: ::std::os::raw::c_uint = 24;
pub const KVM_CAP_IRQ_ROUTING: ::std::os::raw::c_uint = 25;
pub const KVM_CAP_IRQ_INJECT_STATUS: ::std::os::raw::c_uint = 26;
pub const KVM_CAP_ASSIGN_DEV_IRQ: ::std::os::raw::c_uint = 29;
pub const KVM_CAP_JOIN_MEMORY_REGIONS_WORKS: ::std::os::raw::c_uint = 30;
pub const KVM_CAP_MCE: ::std::os::raw::c_uint = 31;
pub const KVM_CAP_IRQFD: ::std::os::raw::c_uint = 32;
pub const KVM_CAP_PIT2: ::std::os::raw::c_uint = 33;
pub const KVM_CAP_SET_BOOT_CPU_ID: ::std::os::raw::c_uint = 34;
pub const KVM_CAP_PIT_STATE2: ::std::os::raw::c_uint = 35;
pub const KVM_CAP_IOEVENTFD: ::std::os::raw::c_uint = 36;
pub const KVM_CAP_SET_IDENTITY_MAP_ADDR: ::std::os::raw::c_uint = 37;
pub const KVM_CAP_XEN_HVM: ::std::os::raw::c_uint = 38;
pub const KVM_CAP_ADJUST_CLOCK: ::std::os::raw::c_uint = 39;
pub const KVM_CAP_INTERNAL_ERROR_DATA: ::std::os::raw::c_uint = 40;
pub const KVM_CAP_VCPU_EVENTS: ::std::os::raw::c_uint = 41;
pub const KVM_CAP_S390_PSW: ::std::os::raw::c_uint = 42;
pub const KVM_CAP_PPC_SEGSTATE: ::std::os::raw::c_uint = 43;
pub const KVM_CAP_HYPERV: ::std::os::raw::c_uint = 44;
pub const KVM_CAP_HYPERV_VAPIC: ::std::os::raw::c_uint = 45;
pub const KVM_CAP_HYPERV_SPIN: ::std::os::raw::c_uint = 46;
pub const KVM_CAP_PCI_SEGMENT: ::std::os::raw::c_uint = 47;
pub const KVM_CAP_PPC_PAIRED_SINGLES: ::std::os::raw::c_uint = 48;
pub const KVM_CAP_INTR_SHADOW: ::std::os::raw::c_uint = 49;
pub const KVM_CAP_DEBUGREGS: ::std::os::raw::c_uint = 50;
pub const KVM_CAP_X86_ROBUST_SINGLESTEP: ::std::os::raw::c_uint = 51;
pub const KVM_CAP_PPC_OSI: ::std::os::raw::c_uint = 52;
pub const KVM_CAP_PPC_UNSET_IRQ: ::std::os::raw::c_uint = 53;
pub const KVM_CAP_ENABLE_CAP: ::std::os::raw::c_uint = 54;
pub const KVM_CAP_XSAVE: ::std::os::raw::c_uint = 55;
pub const KVM_CAP_XCRS: ::std::os::raw::c_uint = 56;
pub const KVM_CAP_PPC_GET_PVINFO: ::std::os::raw::c_uint = 57;
pub const KVM_CAP_PPC_IRQ_LEVEL: ::std::os::raw::c_uint = 58;
pub const KVM_CAP_ASYNC_PF: ::std::os::raw::c_uint = 59;
pub const KVM_CAP_TSC_CONTROL: ::std::os::raw::c_uint = 60;
pub const KVM_CAP_GET_TSC_KHZ: ::std::os::raw::c_uint = 61;
pub const KVM_CAP_PPC_BOOKE_SREGS: ::std::os::raw::c_uint = 62;
pub const KVM_CAP_SPAPR_TCE: ::std::os::raw::c_uint = 63;
pub const KVM_CAP_PPC_SMT: ::std::os::raw::c_uint = 64;
pub const KVM_CAP_PPC_RMA: ::std::os::raw::c_uint = 65;
pub const KVM_CAP_MAX_VCPUS: ::std::os::raw::c_uint = 66;
pub const KVM_CAP_PPC_HIOR: ::std::os::raw::c_uint = 67;
pub const KVM_CAP_PPC_PAPR: ::std::os::raw::c_uint = 68;
pub const KVM_CAP_SW_TLB: ::std::os::raw::c_uint = 69;
pub const KVM_CAP_ONE_REG: ::std::os::raw::c_uint = 70;
pub const KVM_CAP_S390_GMAP: ::std::os::raw::c_uint = 71;
pub const KVM_CAP_TSC_DEADLINE_TIMER: ::std::os::raw::c_uint = 72;
pub const KVM_CAP_S390_UCONTROL: ::std::os::raw::c_uint = 73;
pub const KVM_CAP_SYNC_REGS: ::std::os::raw::c_uint = 74;
pub const KVM_CAP_PCI_2_3: ::std::os::raw::c_uint = 75;
pub const KVM_CAP_KVMCLOCK_CTRL: ::std::os::raw::c_uint = 76;
pub const KVM_CAP_SIGNAL_MSI: ::std::os::raw::c_uint = 77;
pub const KVM_CAP_PPC_GET_SMMU_INFO: ::std::os::raw::c_uint = 78;
pub const KVM_CAP_S390_COW: ::std::os::raw::c_uint = 79;
pub const KVM_CAP_PPC_ALLOC_HTAB: ::std::os::raw::c_uint = 80;
pub const KVM_CAP_READONLY_MEM: ::std::os::raw::c_uint = 81;
pub const KVM_CAP_IRQFD_RESAMPLE: ::std::os::raw::c_uint = 82;
pub const KVM_CAP_PPC_BOOKE_WATCHDOG: ::std::os::raw::c_uint = 83;
pub const KVM_CAP_PPC_HTAB_FD: ::std::os::raw::c_uint = 84;
pub const KVM_CAP_S390_CSS_SUPPORT: ::std::os::raw::c_uint = 85;
pub const KVM_CAP_PPC_EPR: ::std::os::raw::c_uint = 86;
pub const KVM_CAP_ARM_PSCI: ::std::os::raw::c_uint = 87;
pub const KVM_CAP_ARM_SET_DEVICE_ADDR: ::std::os::raw::c_uint = 88;
pub const KVM_CAP_DEVICE_CTRL: ::std::os::raw::c_uint = 89;
pub const KVM_CAP_IRQ_MPIC: ::std::os::raw::c_uint = 90;
pub const KVM_CAP_PPC_RTAS: ::std::os::raw::c_uint = 91;
pub const KVM_CAP_IRQ_XICS: ::std::os::raw::c_uint = 92;
pub const KVM_CAP_ARM_EL1_32BIT: ::std::os::raw::c_uint = 93;
pub const KVM_CAP_SPAPR_MULTITCE: ::std::os::raw::c_uint = 94;
pub const KVM_CAP_EXT_EMUL_CPUID: ::std::os::raw::c_uint = 95;
pub const KVM_CAP_HYPERV_TIME: ::std::os::raw::c_uint = 96;
pub const KVM_CAP_IOAPIC_POLARITY_IGNORED: ::std::os::raw::c_uint = 97;
pub const KVM_CAP_ENABLE_CAP_VM: ::std::os::raw::c_uint = 98;
pub const KVM_CAP_S390_IRQCHIP: ::std::os::raw::c_uint = 99;
pub const KVM_CAP_IOEVENTFD_NO_LENGTH: ::std::os::raw::c_uint = 100;
pub const KVM_CAP_VM_ATTRIBUTES: ::std::os::raw::c_uint = 101;
pub const KVM_CAP_ARM_PSCI_0_2: ::std::os::raw::c_uint = 102;
pub const KVM_CAP_PPC_FIXUP_HCALL: ::std::os::raw::c_uint = 103;
pub const KVM_CAP_PPC_ENABLE_HCALL: ::std::os::raw::c_uint = 104;
pub const KVM_CAP_CHECK_EXTENSION_VM: ::std::os::raw::c_uint = 105;
pub const KVM_CAP_S390_USER_SIGP: ::std::os::raw::c_uint = 106;
pub const KVM_IRQ_ROUTING_IRQCHIP: ::std::os::raw::c_uint = 1;
pub const KVM_IRQ_ROUTING_MSI: ::std::os::raw::c_uint = 2;
pub const KVM_IRQ_ROUTING_S390_ADAPTER: ::std::os::raw::c_uint = 3;
pub const KVM_IRQFD_FLAG_DEASSIGN: ::std::os::raw::c_uint = 1;
pub const KVM_IRQFD_FLAG_RESAMPLE: ::std::os::raw::c_uint = 2;
pub const KVM_MMU_FSL_BOOKE_NOHV: ::std::os::raw::c_uint = 0;
pub const KVM_MMU_FSL_BOOKE_HV: ::std::os::raw::c_uint = 1;
pub const KVM_REG_ARCH_MASK: ::std::os::raw::c_longlong = -72057594037927936;
pub const KVM_REG_GENERIC: ::std::os::raw::c_uint = 0;
pub const KVM_REG_PPC: ::std::os::raw::c_ulonglong = 1152921504606846976;
pub const KVM_REG_X86: ::std::os::raw::c_ulonglong = 2305843009213693952;
pub const KVM_REG_IA64: ::std::os::raw::c_ulonglong = 3458764513820540928;
pub const KVM_REG_ARM: ::std::os::raw::c_ulonglong = 4611686018427387904;
pub const KVM_REG_S390: ::std::os::raw::c_ulonglong = 5764607523034234880;
pub const KVM_REG_ARM64: ::std::os::raw::c_ulonglong = 6917529027641081856;
pub const KVM_REG_MIPS: ::std::os::raw::c_ulonglong = 8070450532247928832;
pub const KVM_REG_SIZE_SHIFT: ::std::os::raw::c_uint = 52;
pub const KVM_REG_SIZE_MASK: ::std::os::raw::c_ulonglong = 67553994410557440;
pub const KVM_REG_SIZE_U8: ::std::os::raw::c_uint = 0;
pub const KVM_REG_SIZE_U16: ::std::os::raw::c_ulonglong = 4503599627370496;
pub const KVM_REG_SIZE_U32: ::std::os::raw::c_ulonglong = 9007199254740992;
pub const KVM_REG_SIZE_U64: ::std::os::raw::c_ulonglong = 13510798882111488;
pub const KVM_REG_SIZE_U128: ::std::os::raw::c_ulonglong = 18014398509481984;
pub const KVM_REG_SIZE_U256: ::std::os::raw::c_ulonglong = 22517998136852480;
pub const KVM_REG_SIZE_U512: ::std::os::raw::c_ulonglong = 27021597764222976;
pub const KVM_REG_SIZE_U1024: ::std::os::raw::c_ulonglong = 31525197391593472;
pub const KVM_CREATE_DEVICE_TEST: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_VFIO_GROUP: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_VFIO_GROUP_ADD: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_VFIO_GROUP_DEL: ::std::os::raw::c_uint = 2;
pub const KVM_S390_STORE_STATUS_NOADDR: ::std::os::raw::c_int = -1;
pub const KVM_S390_STORE_STATUS_PREFIXED: ::std::os::raw::c_int = -2;
pub const KVM_DEV_ASSIGN_ENABLE_IOMMU: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_ASSIGN_PCI_2_3: ::std::os::raw::c_uint = 2;
pub const KVM_DEV_ASSIGN_MASK_INTX: ::std::os::raw::c_uint = 4;
pub const KVM_DEV_IRQ_HOST_INTX: ::std::os::raw::c_uint = 1;
pub const KVM_DEV_IRQ_HOST_MSI: ::std::os::raw::c_uint = 2;
pub const KVM_DEV_IRQ_HOST_MSIX: ::std::os::raw::c_uint = 4;
pub const KVM_DEV_IRQ_GUEST_INTX: ::std::os::raw::c_uint = 256;
pub const KVM_DEV_IRQ_GUEST_MSI: ::std::os::raw::c_uint = 512;
pub const KVM_DEV_IRQ_GUEST_MSIX: ::std::os::raw::c_uint = 1024;
pub const KVM_DEV_IRQ_HOST_MASK: ::std::os::raw::c_uint = 255;
pub const KVM_DEV_IRQ_GUEST_MASK: ::std::os::raw::c_uint = 65280;
pub const KVM_MAX_MSIX_PER_DEV: ::std::os::raw::c_uint = 256;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_memory_alias {
    pub slot: __u32,
    pub flags: __u32,
    pub guest_phys_addr: __u64,
    pub memory_size: __u64,
    pub target_phys_addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_memory_alias() {
    assert_eq!(::std::mem::size_of::<kvm_memory_alias>() , 32usize , concat !
               ( "Size of: " , stringify ! ( kvm_memory_alias ) ));
    assert_eq! (::std::mem::align_of::<kvm_memory_alias>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_memory_alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_alias ) ) . slot as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_alias ) ,
                "::" , stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_alias ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_alias ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_alias ) ) . guest_phys_addr as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_alias ) ,
                "::" , stringify ! ( guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_alias ) ) . memory_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_alias ) ,
                "::" , stringify ! ( memory_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_alias ) ) . target_phys_addr
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_alias ) ,
                "::" , stringify ! ( target_phys_addr ) ));
}
impl Clone for kvm_memory_alias {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_pic_state {
    pub last_irr: __u8,
    pub irr: __u8,
    pub imr: __u8,
    pub isr: __u8,
    pub priority_add: __u8,
    pub irq_base: __u8,
    pub read_reg_select: __u8,
    pub poll: __u8,
    pub special_mask: __u8,
    pub init_state: __u8,
    pub auto_eoi: __u8,
    pub rotate_on_auto_eoi: __u8,
    pub special_fully_nested_mode: __u8,
    pub init4: __u8,
    pub elcr: __u8,
    pub elcr_mask: __u8,
}
#[test]
fn bindgen_test_layout_kvm_pic_state() {
    assert_eq!(::std::mem::size_of::<kvm_pic_state>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_pic_state ) ));
    assert_eq! (::std::mem::align_of::<kvm_pic_state>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_pic_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . last_irr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( last_irr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . irr as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( irr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . imr as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( imr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . isr as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( isr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . priority_add as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( priority_add ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . irq_base as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( irq_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . read_reg_select as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( read_reg_select ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . poll as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . special_mask as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( special_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . init_state as * const
                _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( init_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . auto_eoi as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( auto_eoi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . rotate_on_auto_eoi as
                * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( rotate_on_auto_eoi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) .
                special_fully_nested_mode as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( special_fully_nested_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . init4 as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( init4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . elcr as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( elcr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pic_state ) ) . elcr_mask as * const
                _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pic_state ) , "::"
                , stringify ! ( elcr_mask ) ));
}
impl Clone for kvm_pic_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ioapic_state {
    pub base_address: __u64,
    pub ioregsel: __u32,
    pub id: __u32,
    pub irr: __u32,
    pub pad: __u32,
    pub redirtbl: [kvm_ioapic_state__bindgen_ty_1; 24usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ioapic_state__bindgen_ty_1 {
    pub bits: __BindgenUnionField<__u64>,
    pub fields: __BindgenUnionField<kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 {
    pub vector: __u8,
    pub _bitfield_1: u8,
    pub _bitfield_2: u8,
    pub reserved: [__u8; 4usize],
    pub dest_id: __u8,
}
#[test]
fn bindgen_test_layout_kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1
                ) ) . vector as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( vector ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1
                ) ) . reserved as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1
                ) ) . dest_id as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( dest_id ) ));
}
impl Clone for kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl kvm_ioapic_state__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn delivery_mode(&self) -> __u8 {
        let mask = 7usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: __u8) {
        let mask = 7usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn dest_mode(&self) -> __u8 {
        let mask = 8usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_dest_mode(&mut self, val: __u8) {
        let mask = 8usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn delivery_status(&self) -> __u8 {
        let mask = 16usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: __u8) {
        let mask = 16usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn polarity(&self) -> __u8 {
        let mask = 32usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: __u8) {
        let mask = 32usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn remote_irr(&self) -> __u8 {
        let mask = 64usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: __u8) {
        let mask = 64usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn trig_mode(&self) -> __u8 {
        let mask = 128usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_trig_mode(&mut self, val: __u8) {
        let mask = 128usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        field_val &= !mask;
        field_val |= (val << 7usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn mask(&self) -> __u8 {
        let mask = 1usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: __u8) {
        let mask = 1usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
    #[inline]
    pub fn reserve(&self) -> __u8 {
        let mask = 127usize as u8;
        let field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        let val = (field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_reserve(&mut self, val: __u8) {
        let mask = 127usize as u8;
        let val = val as u8 as u8;
        let mut field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_2) };
        field_val &= !mask;
        field_val |= (val << 0usize) & mask;
        self._bitfield_2 = unsafe { ::std::mem::transmute(field_val) };
    }
}
#[test]
fn bindgen_test_layout_kvm_ioapic_state__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_ioapic_state__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_ioapic_state__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_ioapic_state__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_ioapic_state__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state__bindgen_ty_1 ) ) . bits
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ioapic_state__bindgen_ty_1 ) , "::" , stringify ! ( bits )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state__bindgen_ty_1 ) ) .
                fields as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ioapic_state__bindgen_ty_1 ) , "::" , stringify ! ( fields
                ) ));
}
impl Clone for kvm_ioapic_state__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_ioapic_state() {
    assert_eq!(::std::mem::size_of::<kvm_ioapic_state>() , 216usize , concat !
               ( "Size of: " , stringify ! ( kvm_ioapic_state ) ));
    assert_eq! (::std::mem::align_of::<kvm_ioapic_state>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_ioapic_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state ) ) . base_address as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioapic_state ) ,
                "::" , stringify ! ( base_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state ) ) . ioregsel as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioapic_state ) ,
                "::" , stringify ! ( ioregsel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state ) ) . id as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioapic_state ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state ) ) . irr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioapic_state ) ,
                "::" , stringify ! ( irr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state ) ) . pad as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioapic_state ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioapic_state ) ) . redirtbl as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioapic_state ) ,
                "::" , stringify ! ( redirtbl ) ));
}
impl Clone for kvm_ioapic_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_regs {
    pub rax: __u64,
    pub rbx: __u64,
    pub rcx: __u64,
    pub rdx: __u64,
    pub rsi: __u64,
    pub rdi: __u64,
    pub rsp: __u64,
    pub rbp: __u64,
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
    pub rip: __u64,
    pub rflags: __u64,
}
#[test]
fn bindgen_test_layout_kvm_regs() {
    assert_eq!(::std::mem::size_of::<kvm_regs>() , 144usize , concat ! (
               "Size of: " , stringify ! ( kvm_regs ) ));
    assert_eq! (::std::mem::align_of::<kvm_regs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rax as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rbx as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rcx as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rdx as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rsi as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rdi as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rsp as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rbp as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r8 as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r9 as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r10 as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r11 as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r12 as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r13 as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r14 as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . r15 as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rip as * const _ as usize
                } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_regs ) ) . rflags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_regs ) , "::" ,
                stringify ! ( rflags ) ));
}
impl Clone for kvm_regs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct kvm_lapic_state {
    pub regs: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_kvm_lapic_state() {
    assert_eq!(::std::mem::size_of::<kvm_lapic_state>() , 1024usize , concat !
               ( "Size of: " , stringify ! ( kvm_lapic_state ) ));
    assert_eq! (::std::mem::align_of::<kvm_lapic_state>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( kvm_lapic_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_lapic_state ) ) . regs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_lapic_state ) ,
                "::" , stringify ! ( regs ) ));
}
impl Default for kvm_lapic_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_segment {
    pub base: __u64,
    pub limit: __u32,
    pub selector: __u16,
    pub type_: __u8,
    pub present: __u8,
    pub dpl: __u8,
    pub db: __u8,
    pub s: __u8,
    pub l: __u8,
    pub g: __u8,
    pub avl: __u8,
    pub unusable: __u8,
    pub padding: __u8,
}
#[test]
fn bindgen_test_layout_kvm_segment() {
    assert_eq!(::std::mem::size_of::<kvm_segment>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_segment ) ));
    assert_eq! (::std::mem::align_of::<kvm_segment>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_segment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . limit as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . selector as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( selector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . type_ as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . present as * const _ as
                usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . dpl as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( dpl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . db as * const _ as
                usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( db ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . s as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . l as * const _ as usize
                } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( l ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . g as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . avl as * const _ as
                usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( avl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . unusable as * const _
                as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( unusable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_segment ) ) . padding as * const _ as
                usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_segment ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for kvm_segment {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dtable {
    pub base: __u64,
    pub limit: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_dtable() {
    assert_eq!(::std::mem::size_of::<kvm_dtable>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_dtable ) ));
    assert_eq! (::std::mem::align_of::<kvm_dtable>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_dtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dtable ) ) . base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dtable ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dtable ) ) . limit as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dtable ) , "::" ,
                stringify ! ( limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dtable ) ) . padding as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dtable ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for kvm_dtable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_sregs {
    pub cs: kvm_segment,
    pub ds: kvm_segment,
    pub es: kvm_segment,
    pub fs: kvm_segment,
    pub gs: kvm_segment,
    pub ss: kvm_segment,
    pub tr: kvm_segment,
    pub ldt: kvm_segment,
    pub gdt: kvm_dtable,
    pub idt: kvm_dtable,
    pub cr0: __u64,
    pub cr2: __u64,
    pub cr3: __u64,
    pub cr4: __u64,
    pub cr8: __u64,
    pub efer: __u64,
    pub apic_base: __u64,
    pub interrupt_bitmap: [__u64; 4usize],
}
#[test]
fn bindgen_test_layout_kvm_sregs() {
    assert_eq!(::std::mem::size_of::<kvm_sregs>() , 312usize , concat ! (
               "Size of: " , stringify ! ( kvm_sregs ) ));
    assert_eq! (::std::mem::align_of::<kvm_sregs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_sregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . cs as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . ds as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . es as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . fs as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . gs as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . ss as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . tr as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( tr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . ldt as * const _ as usize
                } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . gdt as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( gdt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . idt as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( idt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . cr0 as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( cr0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . cr2 as * const _ as usize
                } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . cr3 as * const _ as usize
                } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( cr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . cr4 as * const _ as usize
                } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( cr4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . cr8 as * const _ as usize
                } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( cr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . efer as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( efer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . apic_base as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( apic_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_sregs ) ) . interrupt_bitmap as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_sregs ) , "::" ,
                stringify ! ( interrupt_bitmap ) ));
}
impl Clone for kvm_sregs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_fpu {
    pub fpr: [[__u8; 16usize]; 8usize],
    pub fcw: __u16,
    pub fsw: __u16,
    pub ftwx: __u8,
    pub pad1: __u8,
    pub last_opcode: __u16,
    pub last_ip: __u64,
    pub last_dp: __u64,
    pub xmm: [[__u8; 16usize]; 16usize],
    pub mxcsr: __u32,
    pub pad2: __u32,
}
#[test]
fn bindgen_test_layout_kvm_fpu() {
    assert_eq!(::std::mem::size_of::<kvm_fpu>() , 416usize , concat ! (
               "Size of: " , stringify ! ( kvm_fpu ) ));
    assert_eq! (::std::mem::align_of::<kvm_fpu>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_fpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . fpr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( fpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . fcw as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( fcw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . fsw as * const _ as usize }
                , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( fsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . ftwx as * const _ as usize
                } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( ftwx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . pad1 as * const _ as usize
                } , 133usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . last_opcode as * const _ as
                usize } , 134usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( last_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . last_ip as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( last_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . last_dp as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( last_dp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . xmm as * const _ as usize }
                , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . mxcsr as * const _ as usize
                } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_fpu ) ) . pad2 as * const _ as usize
                } , 412usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_fpu ) , "::" ,
                stringify ! ( pad2 ) ));
}
impl Clone for kvm_fpu {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_msr_entry {
    pub index: __u32,
    pub reserved: __u32,
    pub data: __u64,
}
#[test]
fn bindgen_test_layout_kvm_msr_entry() {
    assert_eq!(::std::mem::size_of::<kvm_msr_entry>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_msr_entry ) ));
    assert_eq! (::std::mem::align_of::<kvm_msr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_msr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msr_entry ) ) . index as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msr_entry ) , "::"
                , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msr_entry ) ) . reserved as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msr_entry ) , "::"
                , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msr_entry ) ) . data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msr_entry ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for kvm_msr_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_msrs {
    pub nmsrs: __u32,
    pub pad: __u32,
    pub entries: __IncompleteArrayField<kvm_msr_entry>,
    pub __force_alignment: [u64; 0],
}
#[test]
fn bindgen_test_layout_kvm_msrs() {
    assert_eq!(::std::mem::size_of::<kvm_msrs>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_msrs ) ));
    assert_eq! (::std::mem::align_of::<kvm_msrs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_msrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msrs ) ) . nmsrs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msrs ) , "::" ,
                stringify ! ( nmsrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msrs ) ) . pad as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msrs ) , "::" ,
                stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msrs ) ) . entries as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msrs ) , "::" ,
                stringify ! ( entries ) ));
}
impl Clone for kvm_msrs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_msr_list {
    pub nmsrs: __u32,
    pub indices: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_kvm_msr_list() {
    assert_eq!(::std::mem::size_of::<kvm_msr_list>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_msr_list ) ));
    assert_eq! (::std::mem::align_of::<kvm_msr_list>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_msr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msr_list ) ) . nmsrs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msr_list ) , "::" ,
                stringify ! ( nmsrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msr_list ) ) . indices as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msr_list ) , "::" ,
                stringify ! ( indices ) ));
}
impl Clone for kvm_msr_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_cpuid_entry {
    pub function: __u32,
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
    pub padding: __u32,
}
#[test]
fn bindgen_test_layout_kvm_cpuid_entry() {
    assert_eq!(::std::mem::size_of::<kvm_cpuid_entry>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_cpuid_entry ) ));
    assert_eq! (::std::mem::align_of::<kvm_cpuid_entry>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_cpuid_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry ) ) . function as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry ) ,
                "::" , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry ) ) . eax as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry ) ,
                "::" , stringify ! ( eax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry ) ) . ebx as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry ) ,
                "::" , stringify ! ( ebx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry ) ) . ecx as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry ) ,
                "::" , stringify ! ( ecx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry ) ) . edx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry ) ,
                "::" , stringify ! ( edx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry ) ) . padding as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry ) ,
                "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_cpuid_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_cpuid {
    pub nent: __u32,
    pub padding: __u32,
    pub entries: __IncompleteArrayField<kvm_cpuid_entry>,
}
#[test]
fn bindgen_test_layout_kvm_cpuid() {
    assert_eq!(::std::mem::size_of::<kvm_cpuid>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_cpuid ) ));
    assert_eq! (::std::mem::align_of::<kvm_cpuid>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid ) ) . nent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid ) , "::" ,
                stringify ! ( nent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid ) ) . padding as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid ) , "::" ,
                stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid ) ) . entries as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid ) , "::" ,
                stringify ! ( entries ) ));
}
impl Clone for kvm_cpuid {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_cpuid_entry2 {
    pub function: __u32,
    pub index: __u32,
    pub flags: __u32,
    pub eax: __u32,
    pub ebx: __u32,
    pub ecx: __u32,
    pub edx: __u32,
    pub padding: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_cpuid_entry2() {
    assert_eq!(::std::mem::size_of::<kvm_cpuid_entry2>() , 40usize , concat !
               ( "Size of: " , stringify ! ( kvm_cpuid_entry2 ) ));
    assert_eq! (::std::mem::align_of::<kvm_cpuid_entry2>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_cpuid_entry2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . function as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . index as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . eax as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( eax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . ebx as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( ebx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . ecx as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( ecx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . edx as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( edx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid_entry2 ) ) . padding as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid_entry2 ) ,
                "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_cpuid_entry2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_cpuid2 {
    pub nent: __u32,
    pub padding: __u32,
    pub entries: __IncompleteArrayField<kvm_cpuid_entry2>,
}
#[test]
fn bindgen_test_layout_kvm_cpuid2() {
    assert_eq!(::std::mem::size_of::<kvm_cpuid2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_cpuid2 ) ));
    assert_eq! (::std::mem::align_of::<kvm_cpuid2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_cpuid2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid2 ) ) . nent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid2 ) , "::" ,
                stringify ! ( nent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid2 ) ) . padding as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid2 ) , "::" ,
                stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_cpuid2 ) ) . entries as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_cpuid2 ) , "::" ,
                stringify ! ( entries ) ));
}
impl Clone for kvm_cpuid2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_pit_channel_state {
    pub count: __u32,
    pub latched_count: __u16,
    pub count_latched: __u8,
    pub status_latched: __u8,
    pub status: __u8,
    pub read_state: __u8,
    pub write_state: __u8,
    pub write_latch: __u8,
    pub rw_mode: __u8,
    pub mode: __u8,
    pub bcd: __u8,
    pub gate: __u8,
    pub count_load_time: __s64,
}
#[test]
fn bindgen_test_layout_kvm_pit_channel_state() {
    assert_eq!(::std::mem::size_of::<kvm_pit_channel_state>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_pit_channel_state )
               ));
    assert_eq! (::std::mem::align_of::<kvm_pit_channel_state>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_pit_channel_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . latched_count
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( latched_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . count_latched
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( count_latched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) .
                status_latched as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( status_latched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . status as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . read_state as
                * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( read_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . write_state
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( write_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . write_latch
                as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( write_latch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . rw_mode as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( rw_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . mode as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . bcd as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( bcd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) . gate as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( gate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_channel_state ) ) .
                count_load_time as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_channel_state )
                , "::" , stringify ! ( count_load_time ) ));
}
impl Clone for kvm_pit_channel_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_debug_exit_arch {
    pub exception: __u32,
    pub pad: __u32,
    pub pc: __u64,
    pub dr6: __u64,
    pub dr7: __u64,
}
#[test]
fn bindgen_test_layout_kvm_debug_exit_arch() {
    assert_eq!(::std::mem::size_of::<kvm_debug_exit_arch>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( kvm_debug_exit_arch ) ));
    assert_eq! (::std::mem::align_of::<kvm_debug_exit_arch>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_debug_exit_arch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_exit_arch ) ) . exception as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_exit_arch ) ,
                "::" , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_exit_arch ) ) . pad as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_exit_arch ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_exit_arch ) ) . pc as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_exit_arch ) ,
                "::" , stringify ! ( pc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_exit_arch ) ) . dr6 as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_exit_arch ) ,
                "::" , stringify ! ( dr6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_exit_arch ) ) . dr7 as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_exit_arch ) ,
                "::" , stringify ! ( dr7 ) ));
}
impl Clone for kvm_debug_exit_arch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_guest_debug_arch {
    pub debugreg: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_guest_debug_arch() {
    assert_eq!(::std::mem::size_of::<kvm_guest_debug_arch>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_guest_debug_arch )
               ));
    assert_eq! (::std::mem::align_of::<kvm_guest_debug_arch>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_guest_debug_arch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug_arch ) ) . debugreg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug_arch )
                , "::" , stringify ! ( debugreg ) ));
}
impl Clone for kvm_guest_debug_arch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_pit_state {
    pub channels: [kvm_pit_channel_state; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_pit_state() {
    assert_eq!(::std::mem::size_of::<kvm_pit_state>() , 72usize , concat ! (
               "Size of: " , stringify ! ( kvm_pit_state ) ));
    assert_eq! (::std::mem::align_of::<kvm_pit_state>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_pit_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_state ) ) . channels as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_state ) , "::"
                , stringify ! ( channels ) ));
}
impl Clone for kvm_pit_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_pit_state2 {
    pub channels: [kvm_pit_channel_state; 3usize],
    pub flags: __u32,
    pub reserved: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_kvm_pit_state2() {
    assert_eq!(::std::mem::size_of::<kvm_pit_state2>() , 112usize , concat ! (
               "Size of: " , stringify ! ( kvm_pit_state2 ) ));
    assert_eq! (::std::mem::align_of::<kvm_pit_state2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_pit_state2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_state2 ) ) . channels as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_state2 ) , "::"
                , stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_state2 ) ) . flags as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_state2 ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_state2 ) ) . reserved as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_state2 ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for kvm_pit_state2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_reinject_control {
    pub pit_reinject: __u8,
    pub reserved: [__u8; 31usize],
}
#[test]
fn bindgen_test_layout_kvm_reinject_control() {
    assert_eq!(::std::mem::size_of::<kvm_reinject_control>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_reinject_control )
               ));
    assert_eq! (::std::mem::align_of::<kvm_reinject_control>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_reinject_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_reinject_control ) ) . pit_reinject
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_reinject_control )
                , "::" , stringify ! ( pit_reinject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_reinject_control ) ) . reserved as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_reinject_control )
                , "::" , stringify ! ( reserved ) ));
}
impl Clone for kvm_reinject_control {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vcpu_events {
    pub exception: kvm_vcpu_events__bindgen_ty_1,
    pub interrupt: kvm_vcpu_events__bindgen_ty_2,
    pub nmi: kvm_vcpu_events__bindgen_ty_3,
    pub sipi_vector: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 10usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vcpu_events__bindgen_ty_1 {
    pub injected: __u8,
    pub nr: __u8,
    pub has_error_code: __u8,
    pub pad: __u8,
    pub error_code: __u32,
}
#[test]
fn bindgen_test_layout_kvm_vcpu_events__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_vcpu_events__bindgen_ty_1>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_vcpu_events__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_vcpu_events__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_vcpu_events__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_1 ) ) .
                injected as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_1 ) , "::" , stringify ! (
                injected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_1 ) ) . nr as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_1 ) , "::" , stringify ! ( nr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_1 ) ) .
                has_error_code as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_1 ) , "::" , stringify ! (
                has_error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_1 ) ) . pad
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_1 ) , "::" , stringify ! ( pad )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_1 ) ) .
                error_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_1 ) , "::" , stringify ! (
                error_code ) ));
}
impl Clone for kvm_vcpu_events__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vcpu_events__bindgen_ty_2 {
    pub injected: __u8,
    pub nr: __u8,
    pub soft: __u8,
    pub shadow: __u8,
}
#[test]
fn bindgen_test_layout_kvm_vcpu_events__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<kvm_vcpu_events__bindgen_ty_2>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_vcpu_events__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<kvm_vcpu_events__bindgen_ty_2>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_vcpu_events__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_2 ) ) .
                injected as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_2 ) , "::" , stringify ! (
                injected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_2 ) ) . nr as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_2 ) , "::" , stringify ! ( nr )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_2 ) ) . soft
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_2 ) , "::" , stringify ! ( soft )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_2 ) ) .
                shadow as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_2 ) , "::" , stringify ! ( shadow
                ) ));
}
impl Clone for kvm_vcpu_events__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vcpu_events__bindgen_ty_3 {
    pub injected: __u8,
    pub pending: __u8,
    pub masked: __u8,
    pub pad: __u8,
}
#[test]
fn bindgen_test_layout_kvm_vcpu_events__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<kvm_vcpu_events__bindgen_ty_3>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_vcpu_events__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<kvm_vcpu_events__bindgen_ty_3>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_vcpu_events__bindgen_ty_3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_3 ) ) .
                injected as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_3 ) , "::" , stringify ! (
                injected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_3 ) ) .
                pending as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_3 ) , "::" , stringify ! ( pending
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_3 ) ) .
                masked as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_3 ) , "::" , stringify ! ( masked
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events__bindgen_ty_3 ) ) . pad
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_vcpu_events__bindgen_ty_3 ) , "::" , stringify ! ( pad )
                ));
}
impl Clone for kvm_vcpu_events__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_vcpu_events() {
    assert_eq!(::std::mem::size_of::<kvm_vcpu_events>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kvm_vcpu_events ) ));
    assert_eq! (::std::mem::align_of::<kvm_vcpu_events>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_vcpu_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events ) ) . exception as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_events ) ,
                "::" , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events ) ) . interrupt as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_events ) ,
                "::" , stringify ! ( interrupt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events ) ) . nmi as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_events ) ,
                "::" , stringify ! ( nmi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events ) ) . sipi_vector as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_events ) ,
                "::" , stringify ! ( sipi_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events ) ) . flags as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_events ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vcpu_events ) ) . reserved as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vcpu_events ) ,
                "::" , stringify ! ( reserved ) ));
}
impl Clone for kvm_vcpu_events {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_debugregs {
    pub db: [__u64; 4usize],
    pub dr6: __u64,
    pub dr7: __u64,
    pub flags: __u64,
    pub reserved: [__u64; 9usize],
}
#[test]
fn bindgen_test_layout_kvm_debugregs() {
    assert_eq!(::std::mem::size_of::<kvm_debugregs>() , 128usize , concat ! (
               "Size of: " , stringify ! ( kvm_debugregs ) ));
    assert_eq! (::std::mem::align_of::<kvm_debugregs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_debugregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debugregs ) ) . db as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debugregs ) , "::"
                , stringify ! ( db ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debugregs ) ) . dr6 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debugregs ) , "::"
                , stringify ! ( dr6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debugregs ) ) . dr7 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debugregs ) , "::"
                , stringify ! ( dr7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debugregs ) ) . flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debugregs ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debugregs ) ) . reserved as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debugregs ) , "::"
                , stringify ! ( reserved ) ));
}
impl Clone for kvm_debugregs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct kvm_xsave {
    pub region: [__u32; 1024usize],
}
#[test]
fn bindgen_test_layout_kvm_xsave() {
    assert_eq!(::std::mem::size_of::<kvm_xsave>() , 4096usize , concat ! (
               "Size of: " , stringify ! ( kvm_xsave ) ));
    assert_eq! (::std::mem::align_of::<kvm_xsave>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_xsave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xsave ) ) . region as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xsave ) , "::" ,
                stringify ! ( region ) ));
}
impl Default for kvm_xsave {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_xcr {
    pub xcr: __u32,
    pub reserved: __u32,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_kvm_xcr() {
    assert_eq!(::std::mem::size_of::<kvm_xcr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_xcr ) ));
    assert_eq! (::std::mem::align_of::<kvm_xcr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_xcr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcr ) ) . xcr as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcr ) , "::" ,
                stringify ! ( xcr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcr ) ) . reserved as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcr ) , "::" ,
                stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcr ) ) . value as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcr ) , "::" ,
                stringify ! ( value ) ));
}
impl Clone for kvm_xcr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_xcrs {
    pub nr_xcrs: __u32,
    pub flags: __u32,
    pub xcrs: [kvm_xcr; 16usize],
    pub padding: [__u64; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_xcrs() {
    assert_eq!(::std::mem::size_of::<kvm_xcrs>() , 392usize , concat ! (
               "Size of: " , stringify ! ( kvm_xcrs ) ));
    assert_eq! (::std::mem::align_of::<kvm_xcrs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_xcrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcrs ) ) . nr_xcrs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcrs ) , "::" ,
                stringify ! ( nr_xcrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcrs ) ) . flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcrs ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcrs ) ) . xcrs as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcrs ) , "::" ,
                stringify ! ( xcrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xcrs ) ) . padding as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xcrs ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for kvm_xcrs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_sync_regs {
}
#[test]
fn bindgen_test_layout_kvm_sync_regs() {
    assert_eq!(::std::mem::size_of::<kvm_sync_regs>() , 0usize , concat ! (
               "Size of: " , stringify ! ( kvm_sync_regs ) ));
    assert_eq! (::std::mem::align_of::<kvm_sync_regs>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( kvm_sync_regs ) ));
}
impl Clone for kvm_sync_regs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_user_trace_setup {
    pub buf_size: __u32,
    pub buf_nr: __u32,
}
#[test]
fn bindgen_test_layout_kvm_user_trace_setup() {
    assert_eq!(::std::mem::size_of::<kvm_user_trace_setup>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( kvm_user_trace_setup ) ));
    assert_eq! (::std::mem::align_of::<kvm_user_trace_setup>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_user_trace_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_user_trace_setup ) ) . buf_size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_user_trace_setup )
                , "::" , stringify ! ( buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_user_trace_setup ) ) . buf_nr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_user_trace_setup )
                , "::" , stringify ! ( buf_nr ) ));
}
impl Clone for kvm_user_trace_setup {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_breakpoint {
    pub enabled: __u32,
    pub padding: __u32,
    pub address: __u64,
}
#[test]
fn bindgen_test_layout_kvm_breakpoint() {
    assert_eq!(::std::mem::size_of::<kvm_breakpoint>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_breakpoint ) ));
    assert_eq! (::std::mem::align_of::<kvm_breakpoint>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_breakpoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_breakpoint ) ) . enabled as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_breakpoint ) , "::"
                , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_breakpoint ) ) . padding as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_breakpoint ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_breakpoint ) ) . address as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_breakpoint ) , "::"
                , stringify ! ( address ) ));
}
impl Clone for kvm_breakpoint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_debug_guest {
    pub enabled: __u32,
    pub pad: __u32,
    pub breakpoints: [kvm_breakpoint; 4usize],
    pub singlestep: __u32,
}
#[test]
fn bindgen_test_layout_kvm_debug_guest() {
    assert_eq!(::std::mem::size_of::<kvm_debug_guest>() , 80usize , concat ! (
               "Size of: " , stringify ! ( kvm_debug_guest ) ));
    assert_eq! (::std::mem::align_of::<kvm_debug_guest>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_debug_guest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . enabled as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . breakpoints as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( breakpoints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_debug_guest ) ) . singlestep as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_debug_guest ) ,
                "::" , stringify ! ( singlestep ) ));
}
impl Clone for kvm_debug_guest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_memory_region {
    pub slot: __u32,
    pub flags: __u32,
    pub guest_phys_addr: __u64,
    pub memory_size: __u64,
}
#[test]
fn bindgen_test_layout_kvm_memory_region() {
    assert_eq!(::std::mem::size_of::<kvm_memory_region>() , 24usize , concat !
               ( "Size of: " , stringify ! ( kvm_memory_region ) ));
    assert_eq! (::std::mem::align_of::<kvm_memory_region>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_memory_region ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . slot as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . flags as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . guest_phys_addr
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_memory_region ) ) . memory_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_memory_region ) ,
                "::" , stringify ! ( memory_size ) ));
}
impl Clone for kvm_memory_region {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_userspace_memory_region {
    pub slot: __u32,
    pub flags: __u32,
    pub guest_phys_addr: __u64,
    pub memory_size: __u64,
    pub userspace_addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_userspace_memory_region() {
    assert_eq!(::std::mem::size_of::<kvm_userspace_memory_region>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_userspace_memory_region ) ));
    assert_eq! (::std::mem::align_of::<kvm_userspace_memory_region>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_userspace_memory_region )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) . slot as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! ( slot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) . flags
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) .
                guest_phys_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! (
                guest_phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) .
                memory_size as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! (
                memory_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_userspace_memory_region ) ) .
                userspace_addr as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_userspace_memory_region ) , "::" , stringify ! (
                userspace_addr ) ));
}
impl Clone for kvm_userspace_memory_region {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_level {
    pub __bindgen_anon_1: kvm_irq_level__bindgen_ty_1,
    pub level: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_level__bindgen_ty_1 {
    pub irq: __BindgenUnionField<__u32>,
    pub status: __BindgenUnionField<__s32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_level__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_irq_level__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_irq_level__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_level__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_irq_level__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_level__bindgen_ty_1 ) ) . irq as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_level__bindgen_ty_1 ) , "::" , stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_level__bindgen_ty_1 ) ) . status
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_level__bindgen_ty_1 ) , "::" , stringify ! ( status )
                ));
}
impl Clone for kvm_irq_level__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_irq_level() {
    assert_eq!(::std::mem::size_of::<kvm_irq_level>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_irq_level ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_level>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irq_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_level ) ) . level as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_level ) , "::"
                , stringify ! ( level ) ));
}
impl Clone for kvm_irq_level {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_irqchip {
    pub chip_id: __u32,
    pub pad: __u32,
    pub chip: kvm_irqchip__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_irqchip__bindgen_ty_1 {
    pub dummy: __BindgenUnionField<[::std::os::raw::c_char; 512usize]>,
    pub pic: __BindgenUnionField<kvm_pic_state>,
    pub ioapic: __BindgenUnionField<kvm_ioapic_state>,
    pub bindgen_union_field: [u64; 64usize],
}
#[test]
fn bindgen_test_layout_kvm_irqchip__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_irqchip__bindgen_ty_1>() , 512usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_irqchip__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_irqchip__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irqchip__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip__bindgen_ty_1 ) ) . dummy as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irqchip__bindgen_ty_1 ) , "::" , stringify ! ( dummy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip__bindgen_ty_1 ) ) . pic as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irqchip__bindgen_ty_1 ) , "::" , stringify ! ( pic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip__bindgen_ty_1 ) ) . ioapic as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irqchip__bindgen_ty_1 ) , "::" , stringify ! ( ioapic )
                ));
}
impl Clone for kvm_irqchip__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_irqchip__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_kvm_irqchip() {
    assert_eq!(::std::mem::size_of::<kvm_irqchip>() , 520usize , concat ! (
               "Size of: " , stringify ! ( kvm_irqchip ) ));
    assert_eq! (::std::mem::align_of::<kvm_irqchip>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip ) ) . chip_id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqchip ) , "::" ,
                stringify ! ( chip_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqchip ) , "::" ,
                stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqchip ) ) . chip as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqchip ) , "::" ,
                stringify ! ( chip ) ));
}
impl Clone for kvm_irqchip {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_irqchip {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_pit_config {
    pub flags: __u32,
    pub pad: [__u32; 15usize],
}
#[test]
fn bindgen_test_layout_kvm_pit_config() {
    assert_eq!(::std::mem::size_of::<kvm_pit_config>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kvm_pit_config ) ));
    assert_eq! (::std::mem::align_of::<kvm_pit_config>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_pit_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_config ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_config ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_pit_config ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_pit_config ) , "::"
                , stringify ! ( pad ) ));
}
impl Clone for kvm_pit_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_run {
    pub request_interrupt_window: __u8,
    pub padding1: [__u8; 7usize],
    pub exit_reason: __u32,
    pub ready_for_interrupt_injection: __u8,
    pub if_flag: __u8,
    pub padding2: [__u8; 2usize],
    pub cr8: __u64,
    pub apic_base: __u64,
    pub __bindgen_anon_1: kvm_run__bindgen_ty_1,
    pub kvm_valid_regs: __u64,
    pub kvm_dirty_regs: __u64,
    pub s: kvm_run__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1 {
    pub hw: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_1>,
    pub fail_entry: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_2>,
    pub ex: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_3>,
    pub io: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_4>,
    pub debug: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_5>,
    pub mmio: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_6>,
    pub hypercall: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_7>,
    pub tpr_access: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_8>,
    pub s390_sieic: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_9>,
    pub s390_reset_flags: __BindgenUnionField<__u64>,
    pub s390_ucontrol: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_10>,
    pub dcr: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_11>,
    pub internal: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_12>,
    pub osi: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_13>,
    pub papr_hcall: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_14>,
    pub s390_tsch: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_15>,
    pub epr: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_16>,
    pub system_event: __BindgenUnionField<kvm_run__bindgen_ty_1__bindgen_ty_17>,
    pub padding: __BindgenUnionField<[::std::os::raw::c_char; 256usize]>,
    pub bindgen_union_field: [u64; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_1 {
    pub hardware_exit_reason: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_1 ) ) .
                hardware_exit_reason as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                hardware_exit_reason ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_2 {
    pub hardware_entry_failure_reason: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_2 ) ) .
                hardware_entry_failure_reason as * const _ as usize } , 0usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                hardware_entry_failure_reason ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_3 {
    pub exception: __u32,
    pub error_code: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_3>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_3 ) ) .
                exception as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_3 ) ) .
                error_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                error_code ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_4 {
    pub direction: __u8,
    pub size: __u8,
    pub port: __u16,
    pub count: __u32,
    pub data_offset: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_4>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_4
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                direction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                size as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                port as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_4 ) ) .
                data_offset as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                data_offset ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_5 {
    pub arch: kvm_debug_exit_arch,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_5>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_5
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_5 ) ) .
                arch as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                arch ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_6 {
    pub phys_addr: __u64,
    pub data: [__u8; 8usize],
    pub len: __u32,
    pub is_write: __u8,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_6>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_6
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_6>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                phys_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                len as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_6 ) ) .
                is_write as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                is_write ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_7 {
    pub nr: __u64,
    pub args: [__u64; 6usize],
    pub ret: __u64,
    pub longmode: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_7>() ,
               72usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_7
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_7>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                nr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                args as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                ret as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                ret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                longmode as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                longmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_7 ) ) .
                pad as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                pad ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_8 {
    pub rip: __u64,
    pub is_write: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_8>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_8
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_8>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_8 ) ) .
                rip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) , "::" , stringify ! (
                rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_8 ) ) .
                is_write as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) , "::" , stringify ! (
                is_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_8 ) ) .
                pad as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_8 ) , "::" , stringify ! (
                pad ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_9 {
    pub icptcode: __u8,
    pub ipa: __u16,
    pub ipb: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_9>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( kvm_run__bindgen_ty_1__bindgen_ty_9
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_9>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_9 ) ) .
                icptcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) , "::" , stringify ! (
                icptcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_9 ) ) .
                ipa as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) , "::" , stringify ! (
                ipa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_9 ) ) .
                ipb as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_9 ) , "::" , stringify ! (
                ipb ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_10 {
    pub trans_exc_code: __u64,
    pub pgm_code: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_10>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_10 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_10>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_10 ) )
                . trans_exc_code as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_10 ) , "::" , stringify ! (
                trans_exc_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_10 ) )
                . pgm_code as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_10 ) , "::" , stringify ! (
                pgm_code ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_11 {
    pub dcrn: __u32,
    pub data: __u32,
    pub is_write: __u8,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_11>() ,
               12usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_11 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_11>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_11 ) )
                . dcrn as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) , "::" , stringify ! (
                dcrn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_11 ) )
                . data as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_11 ) )
                . is_write as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_11 ) , "::" , stringify ! (
                is_write ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_12 {
    pub suberror: __u32,
    pub ndata: __u32,
    pub data: [__u64; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_12>() ,
               136usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_12 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_12>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_12 ) )
                . suberror as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) , "::" , stringify ! (
                suberror ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_12 ) )
                . ndata as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) , "::" , stringify ! (
                ndata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_12 ) )
                . data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_12 ) , "::" , stringify ! (
                data ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_13 {
    pub gprs: [__u64; 32usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_13>() ,
               256usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_13 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_13>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_13 ) )
                . gprs as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_13 ) , "::" , stringify ! (
                gprs ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_14 {
    pub nr: __u64,
    pub ret: __u64,
    pub args: [__u64; 9usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_14>() ,
               88usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_14 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_14>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_14 ) )
                . nr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) , "::" , stringify ! (
                nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_14 ) )
                . ret as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) , "::" , stringify ! (
                ret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_14 ) )
                . args as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_14 ) , "::" , stringify ! (
                args ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_15 {
    pub subchannel_id: __u16,
    pub subchannel_nr: __u16,
    pub io_int_parm: __u32,
    pub io_int_word: __u32,
    pub ipb: __u32,
    pub dequeued: __u8,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_15>() ,
               20usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_15 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_15>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . subchannel_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                subchannel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . subchannel_nr as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                subchannel_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . io_int_parm as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                io_int_parm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . io_int_word as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                io_int_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . ipb as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                ipb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_15 ) )
                . dequeued as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_15 ) , "::" , stringify ! (
                dequeued ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_16 {
    pub epr: __u32,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_16>() ,
               4usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_16 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_16>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_16 ) )
                . epr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_16 ) , "::" , stringify ! (
                epr ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_run__bindgen_ty_1__bindgen_ty_17 {
    pub type_: __u32,
    pub flags: __u64,
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1__bindgen_ty_17>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               kvm_run__bindgen_ty_1__bindgen_ty_17 ) ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1__bindgen_ty_17>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_17 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_17 ) )
                . type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_17 ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1__bindgen_ty_17 ) )
                . flags as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_run__bindgen_ty_1__bindgen_ty_17 ) , "::" , stringify ! (
                flags ) ));
}
impl Clone for kvm_run__bindgen_ty_1__bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_1>() , 256usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_run__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_run__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . hw as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( hw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . fail_entry as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( fail_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . ex as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( ex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . io as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . debug as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . mmio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( mmio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . hypercall as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( hypercall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . tpr_access as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( tpr_access ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . s390_sieic as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_sieic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) .
                s390_reset_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_reset_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . s390_ucontrol
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_ucontrol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . dcr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( dcr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . internal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . osi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( osi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . papr_hcall as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( papr_hcall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . s390_tsch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( s390_tsch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . epr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( epr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . system_event
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( system_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_1 ) ) . padding as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_1 )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_run__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct kvm_run__bindgen_ty_2 {
    pub regs: __BindgenUnionField<kvm_sync_regs>,
    pub padding: __BindgenUnionField<[::std::os::raw::c_char; 1024usize]>,
    pub bindgen_union_field: [u8; 1024usize],
}
#[test]
fn bindgen_test_layout_kvm_run__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<kvm_run__bindgen_ty_2>() , 1024usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_run__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_run__bindgen_ty_2>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_run__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_2 ) ) . regs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_2 )
                , "::" , stringify ! ( regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run__bindgen_ty_2 ) ) . padding as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run__bindgen_ty_2 )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_run__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_run__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_kvm_run() {
    assert_eq!(::std::mem::size_of::<kvm_run>() , 1328usize , concat ! (
               "Size of: " , stringify ! ( kvm_run ) ));
    assert_eq! (::std::mem::align_of::<kvm_run>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_run ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . request_interrupt_window as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( request_interrupt_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . padding1 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . exit_reason as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( exit_reason ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) .
                ready_for_interrupt_injection as * const _ as usize } ,
                12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( ready_for_interrupt_injection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . if_flag as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( if_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . padding2 as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . cr8 as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( cr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . apic_base as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( apic_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . kvm_valid_regs as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( kvm_valid_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . kvm_dirty_regs as * const _
                as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( kvm_dirty_regs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_run ) ) . s as * const _ as usize } ,
                304usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_run ) , "::" ,
                stringify ! ( s ) ));
}
impl Clone for kvm_run {
    fn clone(&self) -> Self { *self }
}
impl Default for kvm_run {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_coalesced_mmio_zone {
    pub addr: __u64,
    pub size: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_coalesced_mmio_zone() {
    assert_eq!(::std::mem::size_of::<kvm_coalesced_mmio_zone>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_coalesced_mmio_zone ) ));
    assert_eq! (::std::mem::align_of::<kvm_coalesced_mmio_zone>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_coalesced_mmio_zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_zone ) ) . addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_zone
                ) , "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_zone ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_zone
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_zone ) ) . pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_zone
                ) , "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_coalesced_mmio_zone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_coalesced_mmio {
    pub phys_addr: __u64,
    pub len: __u32,
    pub pad: __u32,
    pub data: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_coalesced_mmio() {
    assert_eq!(::std::mem::size_of::<kvm_coalesced_mmio>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( kvm_coalesced_mmio ) ));
    assert_eq! (::std::mem::align_of::<kvm_coalesced_mmio>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_coalesced_mmio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . phys_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( phys_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . pad as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for kvm_coalesced_mmio {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_coalesced_mmio_ring {
    pub first: __u32,
    pub last: __u32,
    pub coalesced_mmio: __IncompleteArrayField<kvm_coalesced_mmio>,
    pub __force_alignment: [u64; 0],
}
#[test]
fn bindgen_test_layout_kvm_coalesced_mmio_ring() {
    assert_eq!(::std::mem::size_of::<kvm_coalesced_mmio_ring>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_coalesced_mmio_ring ) ));
    assert_eq! (::std::mem::align_of::<kvm_coalesced_mmio_ring>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_coalesced_mmio_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_ring ) ) . first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_ring
                ) , "::" , stringify ! ( first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_ring ) ) . last as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_ring
                ) , "::" , stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_coalesced_mmio_ring ) ) .
                coalesced_mmio as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_coalesced_mmio_ring
                ) , "::" , stringify ! ( coalesced_mmio ) ));
}
impl Clone for kvm_coalesced_mmio_ring {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_translation {
    pub linear_address: __u64,
    pub physical_address: __u64,
    pub valid: __u8,
    pub writeable: __u8,
    pub usermode: __u8,
    pub pad: [__u8; 5usize],
}
#[test]
fn bindgen_test_layout_kvm_translation() {
    assert_eq!(::std::mem::size_of::<kvm_translation>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_translation ) ));
    assert_eq! (::std::mem::align_of::<kvm_translation>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_translation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . linear_address as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( linear_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . physical_address as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( physical_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . valid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . writeable as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( writeable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . usermode as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( usermode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_translation ) ) . pad as * const _ as
                usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_translation ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_translation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_interrupt {
    pub irq: __u32,
}
#[test]
fn bindgen_test_layout_kvm_interrupt() {
    assert_eq!(::std::mem::size_of::<kvm_interrupt>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_interrupt ) ));
    assert_eq! (::std::mem::align_of::<kvm_interrupt>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_interrupt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_interrupt ) ) . irq as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_interrupt ) , "::"
                , stringify ! ( irq ) ));
}
impl Clone for kvm_interrupt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dirty_log {
    pub slot: __u32,
    pub padding1: __u32,
    pub __bindgen_anon_1: kvm_dirty_log__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dirty_log__bindgen_ty_1 {
    pub dirty_bitmap: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub padding2: __BindgenUnionField<__u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_kvm_dirty_log__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_dirty_log__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_dirty_log__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_dirty_log__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_dirty_log__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log__bindgen_ty_1 ) ) .
                dirty_bitmap as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_dirty_log__bindgen_ty_1 ) , "::" , stringify ! (
                dirty_bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log__bindgen_ty_1 ) ) .
                padding2 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_dirty_log__bindgen_ty_1 ) , "::" , stringify ! ( padding2
                ) ));
}
impl Clone for kvm_dirty_log__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_dirty_log() {
    assert_eq!(::std::mem::size_of::<kvm_dirty_log>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_dirty_log ) ));
    assert_eq! (::std::mem::align_of::<kvm_dirty_log>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_dirty_log ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log ) ) . slot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_log ) , "::"
                , stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_log ) ) . padding1 as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_log ) , "::"
                , stringify ! ( padding1 ) ));
}
impl Clone for kvm_dirty_log {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_signal_mask {
    pub len: __u32,
    pub sigset: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_kvm_signal_mask() {
    assert_eq!(::std::mem::size_of::<kvm_signal_mask>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_signal_mask ) ));
    assert_eq! (::std::mem::align_of::<kvm_signal_mask>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_signal_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_signal_mask ) ) . len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_signal_mask ) ,
                "::" , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_signal_mask ) ) . sigset as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_signal_mask ) ,
                "::" , stringify ! ( sigset ) ));
}
impl Clone for kvm_signal_mask {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_tpr_access_ctl {
    pub enabled: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_tpr_access_ctl() {
    assert_eq!(::std::mem::size_of::<kvm_tpr_access_ctl>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( kvm_tpr_access_ctl ) ));
    assert_eq! (::std::mem::align_of::<kvm_tpr_access_ctl>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_tpr_access_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_tpr_access_ctl ) ) . enabled as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_tpr_access_ctl ) ,
                "::" , stringify ! ( enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_tpr_access_ctl ) ) . flags as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_tpr_access_ctl ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_tpr_access_ctl ) ) . reserved as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_tpr_access_ctl ) ,
                "::" , stringify ! ( reserved ) ));
}
impl Clone for kvm_tpr_access_ctl {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_vapic_addr {
    pub vapic_addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_vapic_addr() {
    assert_eq!(::std::mem::size_of::<kvm_vapic_addr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_vapic_addr ) ));
    assert_eq! (::std::mem::align_of::<kvm_vapic_addr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_vapic_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_vapic_addr ) ) . vapic_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_vapic_addr ) , "::"
                , stringify ! ( vapic_addr ) ));
}
impl Clone for kvm_vapic_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_mp_state {
    pub mp_state: __u32,
}
#[test]
fn bindgen_test_layout_kvm_mp_state() {
    assert_eq!(::std::mem::size_of::<kvm_mp_state>() , 4usize , concat ! (
               "Size of: " , stringify ! ( kvm_mp_state ) ));
    assert_eq! (::std::mem::align_of::<kvm_mp_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_mp_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_mp_state ) ) . mp_state as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_mp_state ) , "::" ,
                stringify ! ( mp_state ) ));
}
impl Clone for kvm_mp_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_psw {
    pub mask: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_psw() {
    assert_eq!(::std::mem::size_of::<kvm_s390_psw>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_s390_psw ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_psw>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_s390_psw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_psw ) ) . mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_psw ) , "::" ,
                stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_psw ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_psw ) , "::" ,
                stringify ! ( addr ) ));
}
impl Clone for kvm_s390_psw {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_interrupt {
    pub type_: __u32,
    pub parm: __u32,
    pub parm64: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_interrupt() {
    assert_eq!(::std::mem::size_of::<kvm_s390_interrupt>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_interrupt ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_interrupt>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_interrupt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_interrupt ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_interrupt ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_interrupt ) ) . parm as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_interrupt ) ,
                "::" , stringify ! ( parm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_interrupt ) ) . parm64 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_interrupt ) ,
                "::" , stringify ! ( parm64 ) ));
}
impl Clone for kvm_s390_interrupt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_io_info {
    pub subchannel_id: __u16,
    pub subchannel_nr: __u16,
    pub io_int_parm: __u32,
    pub io_int_word: __u32,
}
#[test]
fn bindgen_test_layout_kvm_s390_io_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_io_info>() , 12usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_io_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_io_info>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_s390_io_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . subchannel_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( subchannel_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . subchannel_nr as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( subchannel_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . io_int_parm as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( io_int_parm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_io_info ) ) . io_int_word as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_io_info ) ,
                "::" , stringify ! ( io_int_word ) ));
}
impl Clone for kvm_s390_io_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_ext_info {
    pub ext_params: __u32,
    pub pad: __u32,
    pub ext_params2: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_ext_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_ext_info>() , 16usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_ext_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_ext_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_ext_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ext_info ) ) . ext_params as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ext_info ) ,
                "::" , stringify ! ( ext_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ext_info ) ) . pad as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ext_info ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ext_info ) ) . ext_params2 as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ext_info ) ,
                "::" , stringify ! ( ext_params2 ) ));
}
impl Clone for kvm_s390_ext_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_pgm_info {
    pub trans_exc_code: __u64,
    pub mon_code: __u64,
    pub per_address: __u64,
    pub data_exc_code: __u32,
    pub code: __u16,
    pub mon_class_nr: __u16,
    pub per_code: __u8,
    pub per_atmid: __u8,
    pub exc_access_id: __u8,
    pub per_access_id: __u8,
    pub op_access_id: __u8,
    pub pad: [__u8; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_s390_pgm_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_pgm_info>() , 40usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_pgm_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_pgm_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_pgm_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . trans_exc_code as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( trans_exc_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . mon_code as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( mon_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_address as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . data_exc_code as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( data_exc_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . code as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . mon_class_nr as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( mon_class_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_code as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_atmid as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_atmid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . exc_access_id as
                * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( exc_access_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . per_access_id as
                * const _ as usize } , 35usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( per_access_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . op_access_id as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( op_access_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_pgm_info ) ) . pad as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_pgm_info ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_s390_pgm_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_prefix_info {
    pub address: __u32,
}
#[test]
fn bindgen_test_layout_kvm_s390_prefix_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_prefix_info>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_prefix_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_prefix_info>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_prefix_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_prefix_info ) ) . address as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_prefix_info )
                , "::" , stringify ! ( address ) ));
}
impl Clone for kvm_s390_prefix_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_extcall_info {
    pub code: __u16,
}
#[test]
fn bindgen_test_layout_kvm_s390_extcall_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_extcall_info>() , 2usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_s390_extcall_info )
               ));
    assert_eq! (::std::mem::align_of::<kvm_s390_extcall_info>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_extcall_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_extcall_info ) ) . code as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_extcall_info )
                , "::" , stringify ! ( code ) ));
}
impl Clone for kvm_s390_extcall_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_emerg_info {
    pub code: __u16,
}
#[test]
fn bindgen_test_layout_kvm_s390_emerg_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_emerg_info>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_emerg_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_emerg_info>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_emerg_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_emerg_info ) ) . code as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_emerg_info ) ,
                "::" , stringify ! ( code ) ));
}
impl Clone for kvm_s390_emerg_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_stop_info {
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_kvm_s390_stop_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_stop_info>() , 4usize , concat !
               ( "Size of: " , stringify ! ( kvm_s390_stop_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_stop_info>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_stop_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_stop_info ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_stop_info ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for kvm_s390_stop_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_mchk_info {
    pub cr14: __u64,
    pub mcic: __u64,
    pub failing_storage_address: __u64,
    pub ext_damage_code: __u32,
    pub pad: __u32,
    pub fixed_logout: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_s390_mchk_info() {
    assert_eq!(::std::mem::size_of::<kvm_s390_mchk_info>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( kvm_s390_mchk_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_mchk_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_s390_mchk_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . cr14 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( cr14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . mcic as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( mcic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) .
                failing_storage_address as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( failing_storage_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . ext_damage_code
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( ext_damage_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . pad as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_mchk_info ) ) . fixed_logout as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_mchk_info ) ,
                "::" , stringify ! ( fixed_logout ) ));
}
impl Clone for kvm_s390_mchk_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_irq {
    pub type_: __u64,
    pub u: kvm_s390_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_irq__bindgen_ty_1 {
    pub io: __BindgenUnionField<kvm_s390_io_info>,
    pub ext: __BindgenUnionField<kvm_s390_ext_info>,
    pub pgm: __BindgenUnionField<kvm_s390_pgm_info>,
    pub emerg: __BindgenUnionField<kvm_s390_emerg_info>,
    pub extcall: __BindgenUnionField<kvm_s390_extcall_info>,
    pub prefix: __BindgenUnionField<kvm_s390_prefix_info>,
    pub stop: __BindgenUnionField<kvm_s390_stop_info>,
    pub mchk: __BindgenUnionField<kvm_s390_mchk_info>,
    pub reserved: __BindgenUnionField<[::std::os::raw::c_char; 64usize]>,
    pub bindgen_union_field: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_s390_irq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_s390_irq__bindgen_ty_1>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_s390_irq__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_irq__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( kvm_s390_irq__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . io as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . ext as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . pgm as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( pgm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . emerg as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( emerg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . extcall
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( extcall )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . prefix
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( prefix )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . stop as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . mchk as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( mchk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq__bindgen_ty_1 ) ) . reserved
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_s390_irq__bindgen_ty_1 ) , "::" , stringify ! ( reserved )
                ));
}
impl Clone for kvm_s390_irq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_s390_irq() {
    assert_eq!(::std::mem::size_of::<kvm_s390_irq>() , 72usize , concat ! (
               "Size of: " , stringify ! ( kvm_s390_irq ) ));
    assert_eq! (::std::mem::align_of::<kvm_s390_irq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_s390_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_irq ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_irq ) ) . u as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_irq ) , "::" ,
                stringify ! ( u ) ));
}
impl Clone for kvm_s390_irq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_guest_debug {
    pub control: __u32,
    pub pad: __u32,
    pub arch: kvm_guest_debug_arch,
}
#[test]
fn bindgen_test_layout_kvm_guest_debug() {
    assert_eq!(::std::mem::size_of::<kvm_guest_debug>() , 72usize , concat ! (
               "Size of: " , stringify ! ( kvm_guest_debug ) ));
    assert_eq! (::std::mem::align_of::<kvm_guest_debug>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_guest_debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug ) ) . control as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug ) ,
                "::" , stringify ! ( control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug ) ) . pad as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_guest_debug ) ) . arch as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_guest_debug ) ,
                "::" , stringify ! ( arch ) ));
}
impl Clone for kvm_guest_debug {
    fn clone(&self) -> Self { *self }
}
pub const kvm_ioeventfd_flag_nr_datamatch: _bindgen_ty_1 = 0;
pub const kvm_ioeventfd_flag_nr_pio: _bindgen_ty_1 = 1;
pub const kvm_ioeventfd_flag_nr_deassign: _bindgen_ty_1 = 2;
pub const kvm_ioeventfd_flag_nr_virtio_ccw_notify: _bindgen_ty_1 = 3;
pub const kvm_ioeventfd_flag_nr_fast_mmio: _bindgen_ty_1 = 4;
pub const kvm_ioeventfd_flag_nr_max: _bindgen_ty_1 = 5;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
pub struct kvm_ioeventfd {
    pub datamatch: __u64,
    pub addr: __u64,
    pub len: __u32,
    pub fd: __s32,
    pub flags: __u32,
    pub pad: [__u8; 36usize],
}
#[test]
fn bindgen_test_layout_kvm_ioeventfd() {
    assert_eq!(::std::mem::size_of::<kvm_ioeventfd>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kvm_ioeventfd ) ));
    assert_eq! (::std::mem::align_of::<kvm_ioeventfd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_ioeventfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . datamatch as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( datamatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . fd as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ioeventfd ) ) . pad as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ioeventfd ) , "::"
                , stringify ! ( pad ) ));
}
impl Default for kvm_ioeventfd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct kvm_enable_cap {
    pub cap: __u32,
    pub flags: __u32,
    pub args: [__u64; 4usize],
    pub pad: [__u8; 64usize],
}
#[test]
fn bindgen_test_layout_kvm_enable_cap() {
    assert_eq!(::std::mem::size_of::<kvm_enable_cap>() , 104usize , concat ! (
               "Size of: " , stringify ! ( kvm_enable_cap ) ));
    assert_eq! (::std::mem::align_of::<kvm_enable_cap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_enable_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . cap as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . args as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_enable_cap ) ) . pad as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_enable_cap ) , "::"
                , stringify ! ( pad ) ));
}
impl Default for kvm_enable_cap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct kvm_ppc_pvinfo {
    pub flags: __u32,
    pub hcall: [__u32; 4usize],
    pub pad: [__u8; 108usize],
}
#[test]
fn bindgen_test_layout_kvm_ppc_pvinfo() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_pvinfo>() , 128usize , concat ! (
               "Size of: " , stringify ! ( kvm_ppc_pvinfo ) ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_pvinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_ppc_pvinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_pvinfo ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_pvinfo ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_pvinfo ) ) . hcall as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_pvinfo ) , "::"
                , stringify ! ( hcall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_pvinfo ) ) . pad as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_pvinfo ) , "::"
                , stringify ! ( pad ) ));
}
impl Default for kvm_ppc_pvinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ppc_one_page_size {
    pub page_shift: __u32,
    pub pte_enc: __u32,
}
#[test]
fn bindgen_test_layout_kvm_ppc_one_page_size() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_one_page_size>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_ppc_one_page_size )
               ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_one_page_size>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_ppc_one_page_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_page_size ) ) . page_shift as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_one_page_size )
                , "::" , stringify ! ( page_shift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_page_size ) ) . pte_enc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_one_page_size )
                , "::" , stringify ! ( pte_enc ) ));
}
impl Clone for kvm_ppc_one_page_size {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ppc_one_seg_page_size {
    pub page_shift: __u32,
    pub slb_enc: __u32,
    pub enc: [kvm_ppc_one_page_size; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_ppc_one_seg_page_size() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_one_seg_page_size>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_ppc_one_seg_page_size ) ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_one_seg_page_size>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_ppc_one_seg_page_size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_seg_page_size ) ) .
                page_shift as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ppc_one_seg_page_size ) , "::" , stringify ! ( page_shift
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_seg_page_size ) ) . slb_enc
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ppc_one_seg_page_size ) , "::" , stringify ! ( slb_enc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_one_seg_page_size ) ) . enc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_ppc_one_seg_page_size ) , "::" , stringify ! ( enc ) ));
}
impl Clone for kvm_ppc_one_seg_page_size {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_ppc_smmu_info {
    pub flags: __u64,
    pub slb_size: __u32,
    pub pad: __u32,
    pub sps: [kvm_ppc_one_seg_page_size; 8usize],
}
#[test]
fn bindgen_test_layout_kvm_ppc_smmu_info() {
    assert_eq!(::std::mem::size_of::<kvm_ppc_smmu_info>() , 592usize , concat
               ! ( "Size of: " , stringify ! ( kvm_ppc_smmu_info ) ));
    assert_eq! (::std::mem::align_of::<kvm_ppc_smmu_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_ppc_smmu_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . slb_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( slb_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . pad as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_ppc_smmu_info ) ) . sps as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_ppc_smmu_info ) ,
                "::" , stringify ! ( sps ) ));
}
impl Clone for kvm_ppc_smmu_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_irqchip {
    pub irqchip: __u32,
    pub pin: __u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_irqchip() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_irqchip>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing_irqchip ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_irqchip>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_irqchip ) ) . irqchip as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_irqchip
                ) , "::" , stringify ! ( irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_irqchip ) ) . pin as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_irqchip
                ) , "::" , stringify ! ( pin ) ));
}
impl Clone for kvm_irq_routing_irqchip {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_msi {
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_msi() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_msi>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( kvm_irq_routing_msi ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_msi>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . address_lo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( address_lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . address_hi as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( address_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . data as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_msi ) ) . pad as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_msi ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for kvm_irq_routing_msi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_s390_adapter {
    pub ind_addr: __u64,
    pub summary_addr: __u64,
    pub ind_offset: __u64,
    pub summary_offset: __u32,
    pub adapter_id: __u32,
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_s390_adapter() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_s390_adapter>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing_s390_adapter ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_s390_adapter>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_s390_adapter )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                ind_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! ( ind_addr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                summary_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                summary_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                ind_offset as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                ind_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                summary_offset as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                summary_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_s390_adapter ) ) .
                adapter_id as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_s390_adapter ) , "::" , stringify ! (
                adapter_id ) ));
}
impl Clone for kvm_irq_routing_s390_adapter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_entry {
    pub gsi: __u32,
    pub type_: __u32,
    pub flags: __u32,
    pub pad: __u32,
    pub u: kvm_irq_routing_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing_entry__bindgen_ty_1 {
    pub irqchip: __BindgenUnionField<kvm_irq_routing_irqchip>,
    pub msi: __BindgenUnionField<kvm_irq_routing_msi>,
    pub adapter: __BindgenUnionField<kvm_irq_routing_s390_adapter>,
    pub pad: __BindgenUnionField<[__u32; 8usize]>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_entry__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing_entry__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_entry__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                irqchip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                irqchip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                msi as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                adapter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry__bindgen_ty_1 ) ) .
                pad as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_irq_routing_entry__bindgen_ty_1 ) , "::" , stringify ! (
                pad ) ));
}
impl Clone for kvm_irq_routing_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_irq_routing_entry() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing_entry>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_irq_routing_entry )
               ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_irq_routing_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . gsi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( gsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . type_ as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing_entry ) ) . u as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing_entry )
                , "::" , stringify ! ( u ) ));
}
impl Clone for kvm_irq_routing_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irq_routing {
    pub nr: __u32,
    pub flags: __u32,
    pub entries: __IncompleteArrayField<kvm_irq_routing_entry>,
    pub __force_alignment: [u64; 0],
}
#[test]
fn bindgen_test_layout_kvm_irq_routing() {
    assert_eq!(::std::mem::size_of::<kvm_irq_routing>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_irq_routing ) ));
    assert_eq! (::std::mem::align_of::<kvm_irq_routing>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_irq_routing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing ) ) . nr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing ) ,
                "::" , stringify ! ( nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing ) ) . flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irq_routing ) ) . entries as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irq_routing ) ,
                "::" , stringify ! ( entries ) ));
}
impl Clone for kvm_irq_routing {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_x86_mce {
    pub status: __u64,
    pub addr: __u64,
    pub misc: __u64,
    pub mcg_status: __u64,
    pub bank: __u8,
    pub pad1: [__u8; 7usize],
    pub pad2: [__u64; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_x86_mce() {
    assert_eq!(::std::mem::size_of::<kvm_x86_mce>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kvm_x86_mce ) ));
    assert_eq! (::std::mem::align_of::<kvm_x86_mce>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_x86_mce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . status as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . misc as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( misc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . mcg_status as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( mcg_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . bank as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( bank ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . pad1 as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_x86_mce ) ) . pad2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_x86_mce ) , "::" ,
                stringify ! ( pad2 ) ));
}
impl Clone for kvm_x86_mce {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_xen_hvm_config {
    pub flags: __u32,
    pub msr: __u32,
    pub blob_addr_32: __u64,
    pub blob_addr_64: __u64,
    pub blob_size_32: __u8,
    pub blob_size_64: __u8,
    pub pad2: [__u8; 30usize],
}
#[test]
fn bindgen_test_layout_kvm_xen_hvm_config() {
    assert_eq!(::std::mem::size_of::<kvm_xen_hvm_config>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( kvm_xen_hvm_config ) ));
    assert_eq! (::std::mem::align_of::<kvm_xen_hvm_config>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_xen_hvm_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . msr as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( msr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . blob_addr_32 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( blob_addr_32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . blob_addr_64 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( blob_addr_64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . blob_size_32 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( blob_size_32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . blob_size_64 as
                * const _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( blob_size_64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_xen_hvm_config ) ) . pad2 as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_xen_hvm_config ) ,
                "::" , stringify ! ( pad2 ) ));
}
impl Clone for kvm_xen_hvm_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_irqfd {
    pub fd: __u32,
    pub gsi: __u32,
    pub flags: __u32,
    pub resamplefd: __u32,
    pub pad: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_irqfd() {
    assert_eq!(::std::mem::size_of::<kvm_irqfd>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kvm_irqfd ) ));
    assert_eq! (::std::mem::align_of::<kvm_irqfd>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_irqfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . fd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . gsi as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( gsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . resamplefd as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( resamplefd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_irqfd ) ) . pad as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_irqfd ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for kvm_irqfd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_clock_data {
    pub clock: __u64,
    pub flags: __u32,
    pub pad: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_kvm_clock_data() {
    assert_eq!(::std::mem::size_of::<kvm_clock_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( kvm_clock_data ) ));
    assert_eq! (::std::mem::align_of::<kvm_clock_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_clock_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_clock_data ) ) . clock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_clock_data ) , "::"
                , stringify ! ( clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_clock_data ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_clock_data ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_clock_data ) ) . pad as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_clock_data ) , "::"
                , stringify ! ( pad ) ));
}
impl Clone for kvm_clock_data {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_config_tlb {
    pub params: __u64,
    pub array: __u64,
    pub mmu_type: __u32,
    pub array_len: __u32,
}
#[test]
fn bindgen_test_layout_kvm_config_tlb() {
    assert_eq!(::std::mem::size_of::<kvm_config_tlb>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_config_tlb ) ));
    assert_eq! (::std::mem::align_of::<kvm_config_tlb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_config_tlb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . params as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . array as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . mmu_type as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( mmu_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_config_tlb ) ) . array_len as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_config_tlb ) , "::"
                , stringify ! ( array_len ) ));
}
impl Clone for kvm_config_tlb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_dirty_tlb {
    pub bitmap: __u64,
    pub num_dirty: __u32,
}
#[test]
fn bindgen_test_layout_kvm_dirty_tlb() {
    assert_eq!(::std::mem::size_of::<kvm_dirty_tlb>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_dirty_tlb ) ));
    assert_eq! (::std::mem::align_of::<kvm_dirty_tlb>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_dirty_tlb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_tlb ) ) . bitmap as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_tlb ) , "::"
                , stringify ! ( bitmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_dirty_tlb ) ) . num_dirty as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_dirty_tlb ) , "::"
                , stringify ! ( num_dirty ) ));
}
impl Clone for kvm_dirty_tlb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_reg_list {
    pub n: __u64,
    pub reg: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_kvm_reg_list() {
    assert_eq!(::std::mem::size_of::<kvm_reg_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kvm_reg_list ) ));
    assert_eq! (::std::mem::align_of::<kvm_reg_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_reg_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_reg_list ) ) . n as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_reg_list ) , "::" ,
                stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_reg_list ) ) . reg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_reg_list ) , "::" ,
                stringify ! ( reg ) ));
}
impl Clone for kvm_reg_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_one_reg {
    pub id: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_one_reg() {
    assert_eq!(::std::mem::size_of::<kvm_one_reg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kvm_one_reg ) ));
    assert_eq! (::std::mem::align_of::<kvm_one_reg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kvm_one_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_one_reg ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_one_reg ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_one_reg ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_one_reg ) , "::" ,
                stringify ! ( addr ) ));
}
impl Clone for kvm_one_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_msi {
    pub address_lo: __u32,
    pub address_hi: __u32,
    pub data: __u32,
    pub flags: __u32,
    pub pad: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_kvm_msi() {
    assert_eq!(::std::mem::size_of::<kvm_msi>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kvm_msi ) ));
    assert_eq! (::std::mem::align_of::<kvm_msi>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . address_lo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( address_lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . address_hi as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( address_hi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . flags as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_msi ) ) . pad as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_msi ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for kvm_msi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_arm_device_addr {
    pub id: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_arm_device_addr() {
    assert_eq!(::std::mem::size_of::<kvm_arm_device_addr>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( kvm_arm_device_addr ) ));
    assert_eq! (::std::mem::align_of::<kvm_arm_device_addr>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_arm_device_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_arm_device_addr ) ) . id as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_arm_device_addr ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_arm_device_addr ) ) . addr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_arm_device_addr ) ,
                "::" , stringify ! ( addr ) ));
}
impl Clone for kvm_arm_device_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_create_device {
    pub type_: __u32,
    pub fd: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_kvm_create_device() {
    assert_eq!(::std::mem::size_of::<kvm_create_device>() , 12usize , concat !
               ( "Size of: " , stringify ! ( kvm_create_device ) ));
    assert_eq! (::std::mem::align_of::<kvm_create_device>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( kvm_create_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_create_device ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_create_device ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_create_device ) ) . fd as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_create_device ) ,
                "::" , stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_create_device ) ) . flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_create_device ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for kvm_create_device {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_device_attr {
    pub flags: __u32,
    pub group: __u32,
    pub attr: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_kvm_device_attr() {
    assert_eq!(::std::mem::size_of::<kvm_device_attr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kvm_device_attr ) ));
    assert_eq! (::std::mem::align_of::<kvm_device_attr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kvm_device_attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . flags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . group as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . attr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_device_attr ) ) . addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_device_attr ) ,
                "::" , stringify ! ( addr ) ));
}
impl Clone for kvm_device_attr {
    fn clone(&self) -> Self { *self }
}
pub const kvm_device_type_KVM_DEV_TYPE_FSL_MPIC_20: kvm_device_type = 1;
pub const kvm_device_type_KVM_DEV_TYPE_FSL_MPIC_42: kvm_device_type = 2;
pub const kvm_device_type_KVM_DEV_TYPE_XICS: kvm_device_type = 3;
pub const kvm_device_type_KVM_DEV_TYPE_VFIO: kvm_device_type = 4;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2: kvm_device_type = 5;
pub const kvm_device_type_KVM_DEV_TYPE_FLIC: kvm_device_type = 6;
pub const kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V3: kvm_device_type = 7;
pub const kvm_device_type_KVM_DEV_TYPE_MAX: kvm_device_type = 8;
pub type kvm_device_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_s390_ucas_mapping {
    pub user_addr: __u64,
    pub vcpu_addr: __u64,
    pub length: __u64,
}
#[test]
fn bindgen_test_layout_kvm_s390_ucas_mapping() {
    assert_eq!(::std::mem::size_of::<kvm_s390_ucas_mapping>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_s390_ucas_mapping )
               ));
    assert_eq! (::std::mem::align_of::<kvm_s390_ucas_mapping>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_s390_ucas_mapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ucas_mapping ) ) . user_addr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ucas_mapping )
                , "::" , stringify ! ( user_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ucas_mapping ) ) . vcpu_addr as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ucas_mapping )
                , "::" , stringify ! ( vcpu_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_s390_ucas_mapping ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_s390_ucas_mapping )
                , "::" , stringify ! ( length ) ));
}
impl Clone for kvm_s390_ucas_mapping {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_pci_dev {
    pub assigned_dev_id: __u32,
    pub busnr: __u32,
    pub devfn: __u32,
    pub flags: __u32,
    pub segnr: __u32,
    pub __bindgen_anon_1: kvm_assigned_pci_dev__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_pci_dev__bindgen_ty_1 {
    pub reserved: __BindgenUnionField<[__u32; 11usize]>,
    pub bindgen_union_field: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_kvm_assigned_pci_dev__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_pci_dev__bindgen_ty_1>() ,
               44usize , concat ! (
               "Size of: " , stringify ! ( kvm_assigned_pci_dev__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_pci_dev__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                kvm_assigned_pci_dev__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_assigned_pci_dev__bindgen_ty_1 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for kvm_assigned_pci_dev__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_assigned_pci_dev() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_pci_dev>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( kvm_assigned_pci_dev )
               ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_pci_dev>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_pci_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) .
                assigned_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . busnr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( busnr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . devfn as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( devfn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . flags as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_pci_dev ) ) . segnr as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_pci_dev )
                , "::" , stringify ! ( segnr ) ));
}
impl Clone for kvm_assigned_pci_dev {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_irq {
    pub assigned_dev_id: __u32,
    pub host_irq: __u32,
    pub guest_irq: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: kvm_assigned_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_irq__bindgen_ty_1 {
    pub reserved: __BindgenUnionField<[__u32; 12usize]>,
    pub bindgen_union_field: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_kvm_assigned_irq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_irq__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( kvm_assigned_irq__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_irq__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_irq__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq__bindgen_ty_1 ) ) .
                reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                kvm_assigned_irq__bindgen_ty_1 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for kvm_assigned_irq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_kvm_assigned_irq() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_irq>() , 64usize , concat !
               ( "Size of: " , stringify ! ( kvm_assigned_irq ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_irq>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( kvm_assigned_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . assigned_dev_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . host_irq as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( host_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . guest_irq as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( guest_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_irq ) ) . flags as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_irq ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for kvm_assigned_irq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_msix_nr {
    pub assigned_dev_id: __u32,
    pub entry_nr: __u16,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_kvm_assigned_msix_nr() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_msix_nr>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( kvm_assigned_msix_nr ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_msix_nr>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_msix_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_nr ) ) .
                assigned_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_nr )
                , "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_nr ) ) . entry_nr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_nr )
                , "::" , stringify ! ( entry_nr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_nr ) ) . padding as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_nr )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_assigned_msix_nr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kvm_assigned_msix_entry {
    pub assigned_dev_id: __u32,
    pub gsi: __u32,
    pub entry: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout_kvm_assigned_msix_entry() {
    assert_eq!(::std::mem::size_of::<kvm_assigned_msix_entry>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( kvm_assigned_msix_entry ) ));
    assert_eq! (::std::mem::align_of::<kvm_assigned_msix_entry>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( kvm_assigned_msix_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) .
                assigned_dev_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( assigned_dev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) . gsi as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( gsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) . entry as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kvm_assigned_msix_entry ) ) . padding as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kvm_assigned_msix_entry
                ) , "::" , stringify ! ( padding ) ));
}
impl Clone for kvm_assigned_msix_entry {
    fn clone(&self) -> Self { *self }
}
