From f2309165752b4af1fb2245fb434f4b0938aecd06 Mon Sep 17 00:00:00 2001
From: Babis Chalios <bchalios@amazon.es>
Date: Wed, 21 Jan 2026 14:33:38 +0000
Subject: [PATCH 1/7] ptp: vmclock: add vm generation counter

Similar to live migration, loading a VM from some saved state (aka
snapshot) is also an event that calls for clock adjustments in the
guest. However, guests might want to take more actions as a response to
such events, e.g. as discarding UUIDs, resetting network connections,
reseeding entropy pools, etc. These are actions that guests don't
typically take during live migration, so add a new field in the
vmclock_abi called vm_generation_counter which informs the guest about
such events.

Hypervisor advertises support for vm_generation_counter through the
VMCLOCK_FLAG_VM_GEN_COUNTER_PRESENT flag. Users need to check the
presence of this bit in vmclock_abi flags field before using this flag.

Signed-off-by: Babis Chalios <bchalios@amazon.es>
Reviewed-by: David Woodhouse <dwmw@amazon.co.uk>
Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
---
 include/uapi/linux/vmclock-abi.h | 93 ++++++++++++++++++--------------
 1 file changed, 54 insertions(+), 39 deletions(-)

diff --git a/include/uapi/linux/vmclock-abi.h b/include/uapi/linux/vmclock-abi.h
index d7ca44313bf8..62b8f2091ca5 100644
--- a/include/uapi/linux/vmclock-abi.h
+++ b/include/uapi/linux/vmclock-abi.h
@@ -67,22 +67,22 @@
 struct vmclock_abi {
 	/* CONSTANT FIELDS */
 	uint32_t magic;
-#define VMCLOCK_MAGIC	0x4b4c4356 /* "VCLK" */
-	uint32_t size;		/* Size of region containing this structure */
-	uint16_t version;	/* 1 */
+#define VMCLOCK_MAGIC 0x4b4c4356 /* "VCLK" */
+	uint32_t size; /* Size of region containing this structure */
+	uint16_t version; /* 1 */
 	uint8_t counter_id; /* Matches VIRTIO_RTC_COUNTER_xxx except INVALID */
-#define VMCLOCK_COUNTER_ARM_VCNT	0
-#define VMCLOCK_COUNTER_X86_TSC		1
-#define VMCLOCK_COUNTER_INVALID		0xff
+#define VMCLOCK_COUNTER_ARM_VCNT 0
+#define VMCLOCK_COUNTER_X86_TSC 1
+#define VMCLOCK_COUNTER_INVALID 0xff
 	uint8_t time_type; /* Matches VIRTIO_RTC_TYPE_xxx */
-#define VMCLOCK_TIME_UTC			0	/* Since 1970-01-01 00:00:00z */
-#define VMCLOCK_TIME_TAI			1	/* Since 1970-01-01 00:00:00z */
-#define VMCLOCK_TIME_MONOTONIC			2	/* Since undefined epoch */
-#define VMCLOCK_TIME_INVALID_SMEARED		3	/* Not supported */
-#define VMCLOCK_TIME_INVALID_MAYBE_SMEARED	4	/* Not supported */
+#define VMCLOCK_TIME_UTC 0 /* Since 1970-01-01 00:00:00z */
+#define VMCLOCK_TIME_TAI 1 /* Since 1970-01-01 00:00:00z */
+#define VMCLOCK_TIME_MONOTONIC 2 /* Since undefined epoch */
+#define VMCLOCK_TIME_INVALID_SMEARED 3 /* Not supported */
+#define VMCLOCK_TIME_INVALID_MAYBE_SMEARED 4 /* Not supported */
 
 	/* NON-CONSTANT FIELDS PROTECTED BY SEQCOUNT LOCK */
-	uint32_t seq_count;	/* Low bit means an update is in progress */
+	uint32_t seq_count; /* Low bit means an update is in progress */
 	/*
 	 * This field changes to another non-repeating value when the CPU
 	 * counter is disrupted, for example on live migration. This lets
@@ -92,19 +92,19 @@ struct vmclock_abi {
 	uint64_t disruption_marker;
 	uint64_t flags;
 	/* Indicates that the tai_offset_sec field is valid */
-#define VMCLOCK_FLAG_TAI_OFFSET_VALID		(1 << 0)
+#define VMCLOCK_FLAG_TAI_OFFSET_VALID (1 << 0)
 	/*
 	 * Optionally used to notify guests of pending maintenance events.
 	 * A guest which provides latency-sensitive services may wish to
 	 * remove itself from service if an event is coming up. Two flags
 	 * indicate the approximate imminence of the event.
 	 */
-#define VMCLOCK_FLAG_DISRUPTION_SOON		(1 << 1) /* About a day */
-#define VMCLOCK_FLAG_DISRUPTION_IMMINENT	(1 << 2) /* About an hour */
-#define VMCLOCK_FLAG_PERIOD_ESTERROR_VALID	(1 << 3)
-#define VMCLOCK_FLAG_PERIOD_MAXERROR_VALID	(1 << 4)
-#define VMCLOCK_FLAG_TIME_ESTERROR_VALID	(1 << 5)
-#define VMCLOCK_FLAG_TIME_MAXERROR_VALID	(1 << 6)
+#define VMCLOCK_FLAG_DISRUPTION_SOON (1 << 1) /* About a day */
+#define VMCLOCK_FLAG_DISRUPTION_IMMINENT (1 << 2) /* About an hour */
+#define VMCLOCK_FLAG_PERIOD_ESTERROR_VALID (1 << 3)
+#define VMCLOCK_FLAG_PERIOD_MAXERROR_VALID (1 << 4)
+#define VMCLOCK_FLAG_TIME_ESTERROR_VALID (1 << 5)
+#define VMCLOCK_FLAG_TIME_MAXERROR_VALID (1 << 6)
 	/*
 	 * If the MONOTONIC flag is set then (other than leap seconds) it is
 	 * guaranteed that the time calculated according this structure at
@@ -118,15 +118,21 @@ struct vmclock_abi {
 	 * a counter reading taken immediately before *clearing* the low
 	 * bit again after the update, using the about-to-be-valid fields.
 	 */
-#define VMCLOCK_FLAG_TIME_MONOTONIC		(1 << 7)
+#define VMCLOCK_FLAG_TIME_MONOTONIC (1 << 7)
+	/*
+	 * If the VM_GEN_COUNTER_PRESENT flag is set, the hypervisor will
+	 * bump the vm_generation_counter field every time the guest is
+	 * loaded from some save state (restored from a snapshot).
+	 */
+#define VMCLOCK_FLAG_VM_GEN_COUNTER_PRESENT (1 << 8)
 
 	uint8_t pad[2];
 	uint8_t clock_status;
-#define VMCLOCK_STATUS_UNKNOWN		0
-#define VMCLOCK_STATUS_INITIALIZING	1
-#define VMCLOCK_STATUS_SYNCHRONIZED	2
-#define VMCLOCK_STATUS_FREERUNNING	3
-#define VMCLOCK_STATUS_UNRELIABLE	4
+#define VMCLOCK_STATUS_UNKNOWN 0
+#define VMCLOCK_STATUS_INITIALIZING 1
+#define VMCLOCK_STATUS_SYNCHRONIZED 2
+#define VMCLOCK_STATUS_FREERUNNING 3
+#define VMCLOCK_STATUS_UNRELIABLE 4
 
 	/*
 	 * The time exposed through this device is never smeared. This field
@@ -138,9 +144,9 @@ struct vmclock_abi {
 	 * in the nearby environment.
 	 */
 	uint8_t leap_second_smearing_hint; /* Matches VIRTIO_RTC_SUBTYPE_xxx */
-#define VMCLOCK_SMEARING_STRICT		0
-#define VMCLOCK_SMEARING_NOON_LINEAR	1
-#define VMCLOCK_SMEARING_UTC_SLS	2
+#define VMCLOCK_SMEARING_STRICT 0
+#define VMCLOCK_SMEARING_NOON_LINEAR 1
+#define VMCLOCK_SMEARING_UTC_SLS 2
 	int16_t tai_offset_sec;
 	uint8_t leap_indicator;
 	/*
@@ -154,13 +160,13 @@ struct vmclock_abi {
 	 * leap second when such smearing may need to continue being applied.
 	 * It is hoped that these will be incorporated into virtio-rtc too.
 	 */
-#define VMCLOCK_LEAP_NONE	0	/* No known nearby leap second */
-#define VMCLOCK_LEAP_PRE_POS	1	/* Positive leap second at EOM */
-#define VMCLOCK_LEAP_PRE_NEG	2	/* Negative leap second at EOM */
-#define VMCLOCK_LEAP_POS	3	/* Set during 23:59:60 second */
-#define VMCLOCK_LEAP_NEG	4	/* Not used in VMCLOCK */
-#define VMCLOCK_LEAP_POST_POS	5
-#define VMCLOCK_LEAP_POST_NEG	6
+#define VMCLOCK_LEAP_NONE 0 /* No known nearby leap second */
+#define VMCLOCK_LEAP_PRE_POS 1 /* Positive leap second at EOM */
+#define VMCLOCK_LEAP_PRE_NEG 2 /* Negative leap second at EOM */
+#define VMCLOCK_LEAP_POS 3 /* Set during 23:59:60 second */
+#define VMCLOCK_LEAP_NEG 4 /* Not used in VMCLOCK */
+#define VMCLOCK_LEAP_POST_POS 5
+#define VMCLOCK_LEAP_POST_NEG 6
 
 	/* Bit shift for counter_period_frac_sec and its error rate */
 	uint8_t counter_period_shift;
@@ -179,10 +185,19 @@ struct vmclock_abi {
 	/*
 	 * Time according to time_type field above.
 	 */
-	uint64_t time_sec;		/* Seconds since time_type epoch */
-	uint64_t time_frac_sec;		/* (seconds >> 64) */
-	uint64_t time_esterror_picosec;	/* (± picoseconds) */
-	uint64_t time_maxerror_picosec;	/* (± picoseconds) */
+	uint64_t time_sec; /* Seconds since time_type epoch */
+	uint64_t time_frac_sec; /* (seconds >> 64) */
+	uint64_t time_esterror_picosec; /* (± picoseconds) */
+	uint64_t time_maxerror_picosec; /* (± picoseconds) */
+
+	/*
+	 * This field changes to another non-repeating value when the guest
+	 * has been loaded from a snapshot. In addition to handling a
+	 * disruption in time (which will also be signalled through the
+	 * disruption_marker field), a guest may wish to discard UUIDs,
+	 * reset network connections, reseed entropy, etc.
+	 */
+	uint64_t vm_generation_counter;
 };
 
 #endif /*  __VMCLOCK_ABI_H__ */
-- 
2.52.0

